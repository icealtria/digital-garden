<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[icealtria's digital garden]]></title><description><![CDATA[Obsidian digital garden]]></description><link>https://rinodg.pages.dev/</link><image><url>https://rinodg.pages.dev/site-lib/media/favicon.png</url><title>icealtria's digital garden</title><link>https://rinodg.pages.dev/</link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 16 Dec 2024 16:20:06 GMT</lastBuildDate><atom:link href="https://rinodg.pages.dev/site-lib/rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 16 Dec 2024 16:20:05 GMT</pubDate><copyright><![CDATA[icealtria]]></copyright><ttl>60</ttl><dc:creator>icealtria</dc:creator><item><title><![CDATA[移动光猫]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="http://192.168.1.1/webcmcc/telnet.html" target="_self">http://192.168.1.1/webcmcc/telnet.html</a>cd /config/workb
` `ps | grep pppd<br><a data-href="被加密的移动光猫 PPPoE 密码" href="https://rinodg.pages.dev/clippings/被加密的移动光猫-pppoe-密码.html" class="internal-link" target="_self" rel="noopener nofollow">被加密的移动光猫 PPPoE 密码</a>]]></description><link>https://rinodg.pages.dev/uncategorized/移动光猫.html</link><guid isPermaLink="false">Uncategorized/移动光猫.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 11 Dec 2024 04:00:20 GMT</pubDate></item><item><title><![CDATA[Clash Meta FCM]]></title><description><![CDATA[
配置文件加上：
hosts: 'mtalk.google.com': 108.177.125.188 'alt1-mtalk.google.com': 3.3.3.3 'alt2-mtalk.google.com': 3.3.3.3 'alt3-mtalk.google.com': 74.125.200.188 'alt4-mtalk.google.com': 74.125.200.188 'alt5-mtalk.google.com': 3.3.3.3 'alt6-mtalk.google.com': 3.3.3.3 'alt7-mtalk.google.com': 74.125.200.188 'alt8-mtalk.google.com': 3.3.3.3
hosts: 'mtalk.google.com': 142.250.157.188 'alt1-mtalk.google.com': 74.125.200.188 'alt2-mtalk.google.com': 142.250.141.188 'alt3-mtalk.google.com': 64.233.171.188 'alt4-mtalk.google.com': 173.194.202.188 'alt5-mtalk.google.com': 74.125.126.188 'alt6-mtalk.google.com': 142.250.115.188 'alt7-mtalk.google.com': 108.177.104.188 'alt8-mtalk.google.com': 142.250.152.188 'dl.google.com': 180.163.151.161 'dl.l.google.com': 180.163.150.33 关掉允许应用绕过 VPN
<a data-tooltip-position="top" aria-label="https://github.com/F122Y/fcm-hosts" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/F122Y/fcm-hosts" target="_self">GitHub - F122Y/fcm-hosts: FCM hosts for China</a>]]></description><link>https://rinodg.pages.dev/翻墙/clash/clash-meta-fcm.html</link><guid isPermaLink="false">翻墙/clash/Clash Meta FCM.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 10 Dec 2024 16:03:35 GMT</pubDate></item><item><title><![CDATA[拓扑排序]]></title><description><![CDATA[拓扑排序（Topological Sorting）是一种对有向无环图（DAG, Directed Acyclic Graph）中节点进行线性排序的方法，使得对于图中的每一条有向边 (u, v)，节点 u 都排在节点 v 的前面。 适用范围： 只适用于 有向无环图（DAG）。
如果图中有环，则无法进行拓扑排序。 结果： 输出是图中节点的一个线性排列（可能不唯一）。
满足「所有前置节点出现在后置节点之前」。 拓扑排序主要用于以下场景：
依赖关系： 任务调度（任务 A 必须先完成，才能进行任务 B）。
软件包依赖（一个软件包依赖另一个包安装）。 解析编译依赖： 编译程序时，先编译依赖的模块。 逻辑依赖： 系统构建和优先级关系处理。 通常有两种常见算法实现拓扑排序：
原理： 从入度为 0 的节点开始处理。
删除节点，并减少其指向节点的入度。
重复此过程，直到所有节点被处理。 步骤： 计算每个节点的入度。
将所有入度为 0 的节点加入队列。
从队列中取出一个节点，将其添加到排序结果中。
删除该节点，并减少所有指向它的节点的入度。
如果某节点的入度变为 0，将其加入队列。
重复步骤 3–5，直到队列为空。 复杂度：O(V + E)，其中 V 是节点数，E 是边数。 原理： 使用递归，从一个节点开始深度搜索。
当所有后继节点都被访问时，将当前节点加入排序结果。 步骤： 初始化一个访问状态表，记录每个节点是否已访问。
遍历每个节点，若未访问则执行以下步骤： 标记节点为「正在访问」。
递归访问所有指向的节点。
标记节点为「已访问」并将其加入排序结果。 排序结果在递归结束时需要反转，得到正确顺序。 复杂度：O(V + E)。
假设有任务依赖关系：
A -&gt; B （完成任务 A 后才能做任务 B）。
B -&gt; C。
A -&gt; D。
拓扑排序步骤：
构建有向图：
A -&gt; B -&gt; C
A -&gt; D 结果可能是：
[A, B, D, C] 或 [A, D, B, C] 两种排序都满足依赖关系。 如果图中有环，拓扑排序无法完成。
如果一个节点同时有多个前置依赖，拓扑排序需要优先满足所有依赖。
function topologicalSort(graph: Map&lt;number, Set&lt;number&gt;&gt;): number[] { const inDegree = new Map&lt;number, number&gt;(); const result: number[] = []; // 初始化入度表 graph.forEach((edges, node) =&gt; { if (!inDegree.has(node)) inDegree.set(node, 0); edges.forEach(edge =&gt; { inDegree.set(edge, (inDegree.get(edge) || 0) + 1); }); }); // 将入度为 0 的节点加入队列 const queue = [...inDegree.entries()].filter(([_, degree]) =&gt; degree === 0).map(([node]) =&gt; node); while (queue.length &gt; 0) { const node = queue.shift()!; result.push(node); // 更新指向节点的入度 graph.get(node)?.forEach(neighbor =&gt; { inDegree.set(neighbor, inDegree.get(neighbor)! - 1); if (inDegree.get(neighbor) === 0) queue.push(neighbor); }); } return result;
}
function topologicalSortDFS(graph: Map&lt;number, Set&lt;number&gt;&gt;): number[] { const visited = new Set&lt;number&gt;(); const result: number[] = []; function dfs(node: number) { if (visited.has(node)) return; visited.add(node); graph.get(node)?.forEach(dfs); result.push(node); } // 遍历所有节点 graph.forEach((_, node) =&gt; { if (!visited.has(node)) dfs(node); }); return result.reverse(); // 结果反转
}
]]></description><link>https://rinodg.pages.dev/computer/data-structure/拓扑排序.html</link><guid isPermaLink="false">Computer/Data Structure/拓扑排序.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 05 Dec 2024 13:31:51 GMT</pubDate></item><item><title><![CDATA[Data Structure]]></title><description><![CDATA[<a data-href="Disjoint Sets" href="https://rinodg.pages.dev/.html" class="internal-link" target="_self" rel="noopener nofollow">Disjoint Sets</a><br>
<a data-href="拓扑排序" href="https://rinodg.pages.dev/computer/data-structure/拓扑排序.html#_0" class="internal-link" target="_self" rel="noopener nofollow">拓扑排序</a><br><a data-href="BST" href="https://rinodg.pages.dev/.html" class="internal-link" target="_self" rel="noopener nofollow">BST</a><br>
<a data-href="Trees &amp; Tree Mutation" href="https://rinodg.pages.dev/computer/cs61a/trees-&amp;-tree-mutation.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Trees &amp; Tree Mutation</a><br>
<a data-href="Red Black Trees" href="https://rinodg.pages.dev/computer/data-structure/red-black-trees.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Red Black Trees</a><br>
<a data-href="Tree Traversals" href="https://rinodg.pages.dev/computer/data-structure/tree-traversals.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Tree Traversals</a><br><a data-href="Priority Queue" href="https://rinodg.pages.dev/computer/data-structure/priority-queue.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Priority Queue</a><br><a data-href="dynamic programming" href="https://rinodg.pages.dev/computer/data-structure/dynamic-programming.html#_0" class="internal-link" target="_self" rel="noopener nofollow">dynamic programming</a>]]></description><link>https://rinodg.pages.dev/computer/data-structure/data-structure.html</link><guid isPermaLink="false">Computer/Data Structure/Data Structure.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 05 Dec 2024 13:30:42 GMT</pubDate></item><item><title><![CDATA[PPP]]></title><description><![CDATA[公式：
: 本国货币与外币之间的汇率。 : 本国的物价水平。 : 外国的物价水平。
解释：
绝对购买力平价理论认为，本国与外国的货币汇率由两国物价水平的比值决定。即：公式：或者：
解释：
相对购买力平价关注的是两国之间物价变化的比率对汇率变化的影响。换句话说，如果一个国家的物价水平相对于另一个国家的物价上升，该国货币应该贬值以保持购买力均衡。
绝对购买力平价：直接用物价比率计算汇率。
相对购买力平价：通过物价变化率预测汇率变化。
]]></description><link>https://rinodg.pages.dev/finance/ppp.html</link><guid isPermaLink="false">Finance/PPP.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 27 Nov 2024 01:21:03 GMT</pubDate></item><item><title><![CDATA[影响外汇价格的因素]]></title><description><![CDATA[通胀越高的国家，这个国家的货币就倾向于越来越不值钱
通货膨胀的影响 长期来看，高通胀会导致货币贬值。
例子：印度卢比、津巴布韦元。 极端案例：津巴布韦 反复的恶性通胀和新货币发行，汇率剧烈波动。 全球同步通胀对汇率的影响
- 通胀差异才是影响汇率的核心。
- 疫情期间各国同步通胀，汇率变化相对平稳。
<a data-href="PPP" href="https://rinodg.pages.dev/finance/ppp.html#_0" class="internal-link" target="_self" rel="noopener nofollow">PPP</a> 利差效应
投资者以借入低利率货币（如日元，利率接近0%），将资金兑换为高利率货币（如美元，利率超过5%）进行投资。
资本流动
高利率国家的债券或存款产品对投资者更有吸引力。投资者为了获得更高的收益，通常会将资金转移到这些国家，进一步增加该国货币需求。
货币政策
当央行提高利率，通常意味着在应对通胀或经济过热。这种政策往往也会被市场解读为该国经济基本面较强，从而提高对该货币的信心。
通常来说利率越高，汇率越高。利率短期内的影响，可能会盖过通胀。<br><a data-href="利差交易" href="https://rinodg.pages.dev/finance/利差交易.html#_0" class="internal-link" target="_self" rel="noopener nofollow">利差交易</a> 国际收支： 贸易顺差、资本账户顺差会推高货币。
中国的双顺差曾导致人民币升值。 风险： 政治、经济风险会引发资本外逃，导致货币贬值。
英国脱欧、土耳其政局动荡等事件均导致本币贬值。 政府持续性支出大于收入，就要借钱，要么外债，要么内债（自己印钱花）,自己印钱还债会导致通货膨胀，大多数情况都是同时发生的
外汇管制、公开市场操作等政策影响汇率。
央行干预有时能短期影响汇率，但长期仍受市场供需影响。
]]></description><link>https://rinodg.pages.dev/finance/影响外汇价格的因素.html</link><guid isPermaLink="false">Finance/影响外汇价格的因素.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 27 Nov 2024 01:13:59 GMT</pubDate></item><item><title><![CDATA[javascript-async]]></title><description><![CDATA[The async function declaration declares an async function where the await keyword is permitted within the function body. The async and await keywords enable asynchronous, <a data-href="Promise" href="https://rinodg.pages.dev/computer/web-applications/promise.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Promise</a>-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.<br>async 函数是使用async关键字声明的函数。async 函数是 <a data-tooltip-position="top" aria-label="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_self"><code></code></a>AsyncFunction 构造函数的实例，并且其中允许使用 await 关键字。async 和 await 关键字让我们可以用一种更简洁的方式写出基于 <a data-href="Promise" href="https://rinodg.pages.dev/computer/web-applications/promise.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Promise</a> 的异步行为，而无需刻意地链式调用 promise。beforeEach(async () =&gt; { await Note.deleteMany({}) console.log('cleared') helper.initialNotes.forEach(async (note) =&gt; { let noteObject = new Note(note) await noteObject.save() console.log('saved') }) console.log('done')
}) test('notes are returned as json', async () =&gt; { console.log('entered test') // ...
}
We save the notes stored in the array into the database inside of a forEach loop. The tests don't quite seem to work however, so we have added some console logs to help us find the problem.The console displays the following output:cleared
done
entered test
saved
saved Despite our use of the async/await syntax, our solution does not work like we expected it to. The test execution begins before the database is initialized!The problem is that every iteration of the forEach loop generates its own asynchronous operation, and beforeEach won't wait for them to finish executing. In other words, the await commands defined inside of the forEach loop are not in the beforeEach function, but in separate functions that beforeEach will not wait for.Since the execution of tests begins immediately after beforeEach has finished executing, the execution of tests begins before the database state is initialized.<br>One way of fixing this is to wait for all of the asynchronous operations to finish executing with the <a data-tooltip-position="top" aria-label="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/all" target="_self">Promise.all</a> method:beforeEach(async () =&gt; { await Note.deleteMany({}) const noteObjects = helper.initialNotes .map(note =&gt; new Note(note)) const promiseArray = noteObjects.map(note =&gt; note.save()) await Promise.all(promiseArray)
})
]]></description><link>https://rinodg.pages.dev/computer/web-applications/javascript-async.html</link><guid isPermaLink="false">Computer/Web Applications/javascript-async.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 23:45:48 GMT</pubDate></item><item><title><![CDATA[Packet Switching]]></title><description><![CDATA[在计算机网络和通讯中，分组交换（英语：<a data-href="packet" href="https://rinodg.pages.dev/computer/computer-networking/packet.html#_0" class="internal-link" target="_self" rel="noopener nofollow">packet</a> switching）是一种相对于电路交换的通信范例，分组（又称消息、或消息碎片）在节点间单独路由，不需要在传输前先建立通信路径。分组交换是数据通信中一种新的且重要的概念，现在是世界上互联网通讯、数据和语音通信中最重要的基础。在此之前，数据通信是基于电路交换的想法，就像在传统的电话电路一样，在通话前先建立专有线路，通信双方要在电路的两端。分组交换技术是在1960年代末出现的，当时美国高级研究计划局（简称ARPA）为实现远程计算机之间的信息交换，资助建设一个试验性的网络，该网络被称为ARPANET。ARPANET的主要研究成果之一就是开发一种新的网络协议，在ARPANET网络上对话必须使用这种网络协议。该协议采用一种新的网络信息传输技术，这就是分组交换技术。分组是由一块用户数据和必要的地址和管理信息组成，保证网络能够将数据传递到目标。类似于从邮局发送的包裹上注明的地址一样,只有提供给网络这些信息，网络（邮局）才能把分组（包裹）往正确的地址传送。<br>分组通过最佳路径（取决于 <a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/w/index.php?title=%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95&amp;action=edit&amp;redlink=1" rel="noopener nofollow" class="external-link is-unresolved" title="路由算法（页面不存在）" href="https://zh.wikipedia.org/w/index.php?title=%E8%B7%AF%E7%94%B1%E7%AE%97%E6%B3%95&amp;action=edit&amp;redlink=1" target="_self">路由算法</a>）路由到目标。但并不是所有在相同两个主机之间传送的分组（即使是来自同一消息的那些分组）一定要沿着相同的路径传送。switches focus on doing just one thing forwarding packets quickly and efficientlyswitches don't have to worry about failures]]></description><link>https://rinodg.pages.dev/computer/computer-networking/packet-switching.html</link><guid isPermaLink="false">Computer/Computer Networking/Packet Switching.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 23:45:48 GMT</pubDate></item><item><title><![CDATA[欢迎，这是我的数字花园]]></title><description><![CDATA[之所以要这样一片数字花园，只是因为我的大脑也像这么一个杂草丛生的地方。一些乱七八糟的，可公开的，不方便写成文章的都放这里好了。想想自己blog一直没怎么动的原因，写文章有<a data-tooltip-position="top" aria-label="写作压力" data-href="写作压力" href="https://rinodg.pages.dev/uncategorized/写作压力.html#_0" class="internal-link" target="_self" rel="noopener nofollow">压力</a>。 况且比较碎片化的信息，做成双链笔记的形式也更合适，当然有空的时候我也尽量分类整理下的。其实我不太想做分类，但是供他人阅览还是有分类好。]]></description><link>https://rinodg.pages.dev/index.html</link><guid isPermaLink="false">index.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 23:13:14 GMT</pubDate></item><item><title><![CDATA[什么是金丝雀安全声明？ - Cloudflare]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="https://www.cloudflare.com/zh-cn/learning/privacy/what-is-warrant-canary/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.cloudflare.com/zh-cn/learning/privacy/what-is-warrant-canary/" target="_self">Read Original</a><br>
“FBI 没有来过这里”；如果该标志被取下，则暗示美国联邦调查局 (FBI) 已经访问了该图书馆内的顾客记录 <a data-tooltip-position="top" aria-label="https://omnivore.app/me/cloudflare-18e5fbe438b#fc95feb4-4fa6-489b-b785-2b0cf9be36f2" rel="noopener nofollow" class="external-link is-unresolved" href="https://omnivore.app/me/cloudflare-18e5fbe438b#fc95feb4-4fa6-489b-b785-2b0cf9be36f2" target="_self">⤴️</a> ]]></description><link>https://rinodg.pages.dev/uncategorized/什么是金丝雀安全声明？-cloudflare.html</link><guid isPermaLink="false">Uncategorized/什么是金丝雀安全声明？ - Cloudflare.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 14:29:54 GMT</pubDate></item><item><title><![CDATA[小鹤双拼 on windows]]></title><description><![CDATA[在注册表编辑器上面的框子里输入注册表路径：计算机\HKEY_CURRENT_USER\SOFTWARE\Microsoft\InputMethod\Settings\CHS鼠标右键点击空白处，添加键值：UserDefinedDoublePinyinScheme0小鹤双拼*2*^*iuvdjhcwfgrxmlnpbksqszxkrltvyovt]]></description><link>https://rinodg.pages.dev/uncategorized/小鹤双拼-on-windows.html</link><guid isPermaLink="false">Uncategorized/小鹤双拼 on windows.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:56:09 GMT</pubDate></item><item><title><![CDATA[清除 Powershell 历史]]></title><description><![CDATA[Remove-Item (Get-PSReadlineOption).HistorySavePath]]></description><link>https://rinodg.pages.dev/uncategorized/清除-powershell-历史.html</link><guid isPermaLink="false">Uncategorized/清除 Powershell 历史.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:56:09 GMT</pubDate></item><item><title><![CDATA[Clash]]></title><link>https://rinodg.pages.dev/翻墙/clash/index.html</link><guid isPermaLink="false">翻墙/clash/index.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:53:56 GMT</pubDate></item><item><title><![CDATA[dialer-proxy]]></title><description><![CDATA[指定当前 proxy 通过下一跳的 dialer-proxy 建立网络连接, 值可以为代理组、代理（proxy-groups, proxy）的同一 name 字段]]></description><link>https://rinodg.pages.dev/翻墙/clash/dialer-proxy.html</link><guid isPermaLink="false">翻墙/clash/dialer-proxy.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:53:56 GMT</pubDate></item><item><title><![CDATA[链式代理]]></title><description><![CDATA[代理链，目前 relay 可以支持 udp 的只有 vmess/vless/trojan/ss/ssr/tuic
wireguard目前不支持在relay中使用，请使用 proxy 中的 <a data-href="dialer-proxy" href="https://rinodg.pages.dev/翻墙/clash/dialer-proxy.html#_0" class="internal-link" target="_self" rel="noopener nofollow">dialer-proxy</a> 配置项Proxy Groups: - name: "relay" type: relay proxies: - http - vmess - ss1 - ss2 Traffic: Clash &lt;-&gt; http &lt;-&gt; vmess &lt;-&gt; ss1 &lt;-&gt; ss2 &lt;-&gt; Internet]]></description><link>https://rinodg.pages.dev/翻墙/clash/链式代理.html</link><guid isPermaLink="false">翻墙/clash/链式代理.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:53:56 GMT</pubDate></item><item><title><![CDATA[WARP]]></title><description><![CDATA[WARP 是 Cloudflare 推出的一项（VPN）服务。]]></description><link>https://rinodg.pages.dev/翻墙/warp.html</link><guid isPermaLink="false">翻墙/WARP.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:53:56 GMT</pubDate></item><item><title><![CDATA[warp ip range]]></title><description><![CDATA[whois -h whois.radb.net -- '-i origin AS13335' | grep -Eo "([0-9.]+){4}/[0-9]+" &gt; cloudflare_ranges.txt]]></description><link>https://rinodg.pages.dev/翻墙/clash/warp-ip-range.html</link><guid isPermaLink="false">翻墙/clash/warp ip range.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:53:56 GMT</pubDate></item><item><title><![CDATA[使用 clash meta + Warp 增强使用机场时的隐私]]></title><description><![CDATA[warp 需要用到的 wireguard 目前不支持在 <a data-tooltip-position="top" aria-label="链式代理" data-href="链式代理" href="https://rinodg.pages.dev/翻墙/clash/链式代理.html#_0" class="internal-link" target="_self" rel="noopener nofollow">relay</a> 中使用， 只能在 proxy 配置 <a data-href="dialer-proxy" href="https://rinodg.pages.dev/翻墙/clash/dialer-proxy.html#_0" class="internal-link" target="_self" rel="noopener nofollow">dialer-proxy</a>proxy-groups 中添加前置代理的分组- {
name: 前置,
type: select,
proxies: [DIRECT, 自动选择, 默认, 香港, 台湾, 美国, 日本, 新加坡, 其它地区],
}
Warp 配置- name: WARP
type: wireguard
server: engage.cloudflareclient.com
port: 2408
ip: 172.16.0.2
ipv6: 2606:4700:110:8f0f:c898:f966:48a7:4ebf
private-key: "private-key"
public-key: "public-key"
udp: true
remote-dns-resolve: true
dns: ["1.1.1.1", "8.8.8.8"]
dialer-proxy: "前置"
上面例子，Clash &lt;-&gt; 前置 &lt;-&gt; WARP &lt;-&gt; Internet
防止机场主监视 机场主是有能力监视你访问的每一个地址和访问时间，特别是某些机场主有恶俗倾向。如果套上 warp，机场主就只能看到 warp 的加密流量。 访问机场禁止访问的网站
]]></description><link>https://rinodg.pages.dev/翻墙/clash/使用-clash-meta-+-warp-增强使用机场时的隐私.html</link><guid isPermaLink="false">翻墙/clash/使用 clash meta + Warp 增强使用机场时的隐私.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:53:56 GMT</pubDate></item><item><title><![CDATA[写作压力]]></title><description><![CDATA[大概就是每次提笔（其实是键盘），都会想着我要提供些有价值的东西。
我希望有独创的内容，文章结构清晰、思路连贯。然后我改来改去但最终还是感觉不满意，然后就丢掉了。虽然我明白，写博客不必太严肃正式，又不是投稿顶级期刊。但是吧。]]></description><link>https://rinodg.pages.dev/uncategorized/写作压力.html</link><guid isPermaLink="false">Uncategorized/写作压力.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:53:56 GMT</pubDate></item><item><title><![CDATA[telegram avatar]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="https://t.me/i/userpic/320/%7Busername%7D.jpg" rel="noopener nofollow" class="external-link is-unresolved" href="https://t.me/i/userpic/320/%7Busername%7D.jpg" target="_self">https://t.me/i/userpic/320/{username}.jpg</a>Telegram 直接获取 Public Chat （包括用户）头像的接口如果想在网站，比如个人博客上，挂一个链接到 tg 账户并且能自动更新的头像，就可以使用这个接口。如果怕这个链接国内直连访问不了，可以使用 WordPress 提供的图片代理：<br><a data-tooltip-position="top" aria-label="https://i0.wp.com/t.me/i/userpic/320/%7Busername%7D.jpg" rel="noopener nofollow" class="external-link is-unresolved" href="https://i0.wp.com/t.me/i/userpic/320/%7Busername%7D.jpg" target="_self">https://i0.wp.com/t.me/i/userpic/320/{username}.jpg</a><br><a href="https://rinodg.pages.dev?query=tag:telegram" class="tag is-unresolved" target="_self" rel="noopener nofollow" data-href="#telegram">#telegram</a>]]></description><link>https://rinodg.pages.dev/uncategorized/telegram-avatar.html</link><guid isPermaLink="false">Uncategorized/telegram avatar.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:53:56 GMT</pubDate></item><item><title><![CDATA[Google 地区]]></title><description><![CDATA[查询谷歌账号采用了哪一个国家/地区版本的服务条款。也许和你预测的不一样。<a rel="noopener nofollow" class="external-link is-unresolved" href="https://policies.google.com/terms" target="_self">https://policies.google.com/terms</a>]]></description><link>https://rinodg.pages.dev/uncategorized/google-地区.html</link><guid isPermaLink="false">Uncategorized/Google 地区.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:53:56 GMT</pubDate></item><item><title><![CDATA[利差交易]]></title><description><![CDATA[利差交易（Carry Trade）的核心是套利： 借入低利率货币（如日元，利率接近0%）。
将资金兑换为高利率货币（如美元，利率超过5%）进行投资。
收益包括： 利率差收益：高利率资产带来的固定回报。 汇率波动收益：低利率货币贬值可进一步扩大利润。 自2021年起，美联储大幅加息以应对通胀，而日本央行继续执行超低利率政策，导致两国利差扩大。
这种背景下，大量投资者： 借日元，然后投资美元资产。 汇率方面：卖出日元，买入美元，进一步压低日元汇率。 日元兑美元汇率从100跌至150（2023年期间）。 日本央行多次入市干预，效果有限。 利差扩大：资金持续流入高利率国家，低利率货币贬值。 政策预期变化：若市场预期日本加息、美国降息，资金会迅速撤出。
例如，2023年底，市场预计日元加息，美元降息，日元迅速反弹。 平仓离场：投资者卖出美元、买回日元，导致日元汇率反弹。 踩踏效应：离场集中发生，形成短期剧烈波动。
日元常被视为避险资产，原因与利差交易密切相关：
核灾、海啸引发市场恐慌。 投资者平仓利差交易，大量买回日元。 日元迅速升值，创下历史高位。 G7国家央行联手抛售日元，打压其汇率。 这是美联储自1995年以来首次大规模干预外汇市场。 短期内日元贬值至1美元兑85日元。 但市场力量强大，日元再次迅速升值，日本央行两次单独干预均失败。
日本长期维持低利率，日元成为利差交易的主要融资货币：
借日元，投资澳元、新西兰元，日元兑这两种货币持续贬值。 2008年金融危机：利差交易资金撤出，澳元、新西兰元暴跌。 澳大利亚经常账户长期逆差，需要吸引外资补充。 外资通过利差交易大量购买澳大利亚国债，导致其外债比例一度高达80%。 汇率风险：
若高利率货币突然贬值，可能造成重大亏损。 市场波动：
遇到危机时，投资者平仓引发大规模资本流动，造成踩踏效应。 政策风险：
各国央行干预、利率政策调整都会直接影响利差交易。
外汇市场资金流动规模巨大，哪怕是G7央行联合干预，也难以逆转长期趋势。
这使得外汇市场波动复杂多样，但其背后的逻辑依然围绕套利和避险情绪。 利差交易是外汇市场中最基本、最重要的驱动力之一。从套利机制到市场波动，再到避险属性，它贯穿了全球金融市场的各个层面。
了解这一逻辑，能够帮助我们更好地理解外汇市场的涨跌背后那些复杂但又规律的力量。利率就是平稳投资，风险在于国家信用，股票就是风险投资风险在于市炀波动]]></description><link>https://rinodg.pages.dev/finance/利差交易.html</link><guid isPermaLink="false">Finance/利差交易.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:47:58 GMT</pubDate></item><item><title><![CDATA[国际收支、双顺差与货币升值]]></title><description><![CDATA[国际收支是一个国家在一定时期内（通常是一年）与世界其他国家或地区的全部经济交易的系统记录。简单来说，就是一国在国际上“收支”情况的账本。这个账本主要分两个账户：
经常账户： 主要记录货物和服务贸易、所得收入和经常转移等产生的资金流动。
资本账户： 主要记录直接投资、证券投资、金融衍生品等资本流动。 贸易顺差： 指一个国家在一定时期内出口商品和服务的总值大于进口商品和服务的总值。也就是说，这个国家卖出去的东西比买进的东西多，赚了外汇。
资本账户顺差： 指一个国家在一定时期内流入的资本大于流出的资本。也就是说，外国投资者愿意把钱投到这个国家来，可能是投资工厂、购买股票、债券等。
当一个国家同时出现贸易顺差和资本账户顺差时，我们称之为“双顺差”。双顺差对货币升值有显著的推动作用。原因如下： 外汇需求增加： 贸易顺差： 当一个国家出口增加，外国需要用本国的货币来购买该国的商品，这增加了对本国货币的需求。
资本账户顺差： 外国投资者为了投资该国的企业或购买该国的资产，需要兑换成本国货币，同样增加了对本国货币的需求。 外汇供给减少： 由于贸易顺差，该国企业获得大量外汇，但由于资本账户顺差，这些外汇又流向了国内，导致市场上流通的外汇减少。 货币升值： 当一种货币的需求增加，供给减少时，其汇率就会升高。也就是说，用外币兑换本国货币需要付出更多的外币，即本国货币升值。 在过去很长一段时间里，中国一直保持着贸易顺差和资本账户顺差的“双顺差”格局。这主要得益于：
出口导向型经济： 中国的制造业发达，产品具有价格优势，出口到全球各地。
外商直接投资： 外国企业看重中国巨大的市场潜力和廉价劳动力，纷纷来华投资建厂。
储蓄率高： 中国居民的储蓄率较高，为投资提供了充足的资金。
双顺差推动了人民币的持续升值。 然而，人民币升值也带来了一些问题，比如：
出口企业压力增大： 人民币升值使得中国出口产品的价格在国际市场上相对提高，削弱了中国产品的竞争力。
通货膨胀压力： 大量外汇流入，可能导致国内流动性过剩，引发通货膨胀。
为了应对人民币升值带来的问题，中国政府采取了一系列措施，包括：
外汇干预： 央行通过买卖外汇来调节汇率。
资本管制： 对资本流动进行限制，以减缓人民币升值的速度。
鼓励人民币国际化： 扩大人民币的使用范围，增强人民币的国际地位。
总结国际收支的双顺差对一国货币的升值具有显著的推动作用。然而，货币升值也会带来一些负面影响。因此，各国政府在制定经济政策时，需要综合考虑汇率的波动对经济的影响，并采取相应的措施。]]></description><link>https://rinodg.pages.dev/finance/国际收支、双顺差与货币升值.html</link><guid isPermaLink="false">Finance/国际收支、双顺差与货币升值.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 13:47:58 GMT</pubDate></item><item><title><![CDATA[通货膨胀]]></title><description><![CDATA[通货膨胀是指商品和服务的总体价格水平上涨，导致货币购买力下降的现象通货膨胀是指货币的购买力降低，导致价格普遍上涨的现象。这意味着相同的金额的钱能购买的商品和服务减少。通货膨胀通常由以下因素引起：
需求拉动：当需求超过供给时，企业可能提高价格以平衡市场。
成本推动：生产成本上升（例如原材料价格或劳动力成本的增加）可能导致企业提高商品价格。
货币供应增加：中央银行过度发行货币，增加市场上的货币量，也可能使价格上涨。
持续的高通货膨胀会引起经济不稳定，因此各国政府和中央银行通常会采取措施来控制通货膨胀。]]></description><link>https://rinodg.pages.dev/finance/通货膨胀.html</link><guid isPermaLink="false">Finance/通货膨胀.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 26 Nov 2024 07:16:53 GMT</pubDate></item><item><title><![CDATA[添加用户]]></title><description><![CDATA[Linux下创建用户时会用到useradd和adduser这两个命令，他们的区别如下：
使用useradd时，如果后面不添加任何参数选项，例如：#sudo useradd test创建出来的用户将是默认“三无”用户：一无Home Directory，二无密码，三无系统Shell。
使用adduser时，创建用户的过程更像是一种人机对话，系统会提示你输入各种信息，然后会根据这些信息帮你创建新用户。 adduser会提示设置密码，而useradd不会。
adduser会创建用户目录，比如/home/freebird freebird是用户，useradd不会
dduser会创建用户目录，比如/home/freebird freebird是用户，useradd不会
adduser会询问全名，房间号码，电话号码等用户信息，useradd不会
]]></description><link>https://rinodg.pages.dev/linux/添加用户.html</link><guid isPermaLink="false">Linux/添加用户.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 28 Oct 2024 03:25:01 GMT</pubDate></item><item><title><![CDATA[Logo]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Logo_(programming_language)" target="_self">https://en.wikipedia.org/wiki/Logo_(programming_language)</a>]]></description><link>https://rinodg.pages.dev/computer/logo.html</link><guid isPermaLink="false">Computer/Logo.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 12 Sep 2024 02:58:22 GMT</pubDate></item><item><title><![CDATA[端口占用]]></title><description><![CDATA[在 Linux 上，可以使用以下几种方法查看端口占用情况： netstat 命令：
sudo netstat -tuln | grep LISTEN -t：显示 TCP 端口
-u：显示 UDP 端口
-l：显示监听状态的端口
-n：数字格式显示地址和端口
grep LISTEN：过滤出处于监听状态的端口 ss 命令（更现代的工具）：
sudo ss -tuln 功能和 netstat 类似，但效率更高，通常是现代系统上的默认工具。 lsof 命令：
查看指定端口是否被占用：
sudo lsof -i :&lt;port&gt; 例如，查看 8080 端口是否被占用：
sudo lsof -i :8080 fuser 命令：
查看特定端口的使用情况：
sudo fuser -n tcp &lt;port&gt; 例如，查看 8080 端口：
sudo fuser -n tcp 8080 这些命令都可以帮助你快速确定某个端口的使用情况。]]></description><link>https://rinodg.pages.dev/linux/端口占用.html</link><guid isPermaLink="false">Linux/端口占用.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sun, 08 Sep 2024 15:16:06 GMT</pubDate></item><item><title><![CDATA[zod]]></title><description><![CDATA[I think this would be the answer, zod has it's own utility to quickly coerce the type:console.log(z.coerce.string().parse(1)); // "1"
console.log(z.coerce.string().parse('1')); // "1"
console.log(z.coerce.number().parse(1)); // 1
console.log(z.coerce.number().parse('1')); // 1
If you want a bit more control you should look into preprocessconsole.log(z.preprocess((x) =&gt; '' + x, z.string()).parse(1)); // "1"
console.log(z.preprocess((x) =&gt; Number(x), z.number()).parse('1')); // 1
or transform and pipeconsole.log(z.union([z.string(), z.number()]).transform((x) =&gt; '' + x).pipe(z.string()).parse(1)); // "1"
console.log(z.union([z.string(), z.number()]).transform((x) =&gt; Number(x)).pipe(z.number()).parse('1')); // 1
or pipe and coerceconsole.log(z.union([z.string(), z.number()]).pipe(z.coerce.string()).parse(1)); // "1"
console.log(z.union([z.string(), z.number()]).pipe(z.coerce.number()).parse('1') ); // 1 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://zod.dev/?id=coercion-for-primitives" target="_self">https://zod.dev/?id=coercion-for-primitives</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://zod.dev/?id=preprocess" target="_self">https://zod.dev/?id=preprocess</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://zod.dev/?id=pipe" target="_self">https://zod.dev/?id=pipe</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://twitter.com/colinhacks/status/1602238724120924160?lang=en" target="_self">https://twitter.com/colinhacks/status/1602238724120924160?lang=en</a>
]]></description><link>https://rinodg.pages.dev/dev/web/zod.html</link><guid isPermaLink="false">Dev/web/zod.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sun, 11 Aug 2024 09:43:41 GMT</pubDate></item><item><title><![CDATA[网络掩码]]></title><description><![CDATA[<a data-href="子网" href="https://rinodg.pages.dev/computer/computer-networking/子网.html#_0" class="internal-link" target="_self" rel="noopener nofollow">子网</a>掩码是一个32位地址，用于屏蔽IP地址的一部分以区别网络标识和主机标识，并说明该IP地址是在局域网上，还是在远程网上。它只有一个作用，就是将某个IP地址划分成网络地址和主机地址两部分。某个小型公司有四个部门：行政、研发、营销、售后，每个部门各40台计算机接入公司局域网交换机，如果要在192.168.1.0网段为每个部门划分子网，子网掩码应该怎么设置，每个子网的地址范围分别是什么？192.168.1.0网段共256个地址，划分4个子网，每个子网需要64个地址；64是2的6次方，子网掩码应该以6个0结尾，剩下的用1补齐，由26个1和6个0组成，转换成十进制是255.255.255.192；每个子网共64个IP地址，掐头去尾后可用地址只有62个，第1个子网的可用IP地址范围是：192.168.1.1-62，第2个子网可用IP地址范围是192.168.1.65-126，第3个子网的可用IP地址范围是：192.168.1.129-190，第4个子网可用IP地址范围是192.168.1.193-254；该公司各部门计算机按照3中的IP地址范围进行设置，所有计算机的子网掩码都必须设置为255.255.255.192，设置完毕后各部门内的计算机能正常联网，不同部门间的计算机无法直接联通。]]></description><link>https://rinodg.pages.dev/computer/computer-networking/网络掩码.html</link><guid isPermaLink="false">Computer/Computer Networking/网络掩码.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 07 Jun 2024 15:41:12 GMT</pubDate></item><item><title><![CDATA[Anycast]]></title><description><![CDATA[Anycast 是另一种用于在计算机网络中发送数据的通信方法，与<a data-href="多播" href="https://rinodg.pages.dev/computer/computer-networking/多播.html#_0" class="internal-link" target="_self" rel="noopener nofollow">多播</a>（Multicast）和<a data-href="广播" href="https://rinodg.pages.dev/computer/computer-networking/广播.html#_0" class="internal-link" target="_self" rel="noopener nofollow">广播</a>（Broadcast）不同。以下是 Anycast 的详细解释及其与<a data-href="多播" href="https://rinodg.pages.dev/computer/computer-networking/多播.html#_0" class="internal-link" target="_self" rel="noopener nofollow">多播</a>和<a data-href="广播" href="https://rinodg.pages.dev/computer/computer-networking/广播.html#_0" class="internal-link" target="_self" rel="noopener nofollow">广播</a>的比较：
Anycast发送范围：Anycast 是将数据包发送到多个可能的接收者中的一个，通常是离发送者最近的一个。它依赖于网络路由来决定哪个接收者将实际接收到数据包。目标：Anycast 的目标是一组设备中最优的一个接收者。多个设备共享一个 Anycast 地址，但只有一个设备会接收到每个数据包。使用场景：Anycast 常用于提高服务的可用性和性能，例如内容分发网络（CDN）、DNS 服务和负载均衡。它可以将用户请求引导到最近或最优的服务器节点。效率：Anycast 提高了网络服务的效率和可靠性，因为它可以自动将流量分配到最优的服务器，减少延迟并提高容错能力。]]></description><link>https://rinodg.pages.dev/computer/computer-networking/anycast.html</link><guid isPermaLink="false">Computer/Computer Networking/Anycast.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 07 Jun 2024 15:41:02 GMT</pubDate></item><item><title><![CDATA[IPsec]]></title><description><![CDATA[IPsec（Internet Protocol Security）是一套用于确保通过互联网协议（IP）进行通信的网络安全协议。它通过加密和认证机制来保护数据的机密性、完整性和真实性，从而确保数据在网络上传输时的安全。IPsec 是一种通用的安全协议，广泛应用于虚拟专用网络（VPN）和其他需要安全通信的网络服务。
数据加密：通过加密确保数据的机密性，使得未经授权的用户无法读取数据。
数据完整性：通过哈希函数确保数据在传输过程中没有被篡改。
数据认证：验证数据发送者的身份，确保数据来自合法的发送者。
防重放攻击：通过序列号和时间戳防止数据包被截获并重发。
IPsec 由两部分组成：安全协议和密钥管理协议。
AH（Authentication Header）： 提供数据完整性和认证，但不提供加密。
确保数据未被篡改，并验证数据的来源。 ESP（Encapsulating Security Payload）： 提供数据加密、数据完整性和认证。
比 AH 更常用，因为它提供更全面的安全功能。 IKE（Internet Key Exchange）： 用于在通信双方之间建立和管理安全关联（SA）。
负责生成和交换密钥，并协商加密和认证算法。 IPsec 可以在两种模式下工作：传输模式和隧道模式。 传输模式（Transport Mode）： 仅对 IP 数据包的有效负载进行加密和认证。
通常用于终端到终端的通信，如主机到主机之间的通信。 隧道模式（Tunnel Mode）： 对整个 IP 数据包进行加密和认证，然后封装在一个新的 IP 数据包中。
常用于网关到网关的通信，如两个网络之间的 VPN。 VPN（虚拟专用网络）：通过加密隧道在公共网络上建立安全的私有通信通道。
远程访问：确保远程用户安全地访问企业内部网络。
安全路由：保护路由器之间的通信，防止路由信息被篡改或窃取。
企业网络安全：保护企业内部和外部网络的通信，防止数据泄露和攻击。
IPsec 是一种强大的网络安全协议，通过提供加密、认证和完整性保护来确保数据在网络上传输时的安全。它广泛应用于各种需要安全通信的场景，尤其是在构建 VPN 和保护企业网络通信方面。]]></description><link>https://rinodg.pages.dev/computer/computer-networking/ipsec.html</link><guid isPermaLink="false">Computer/Computer Networking/IPsec.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 07 Jun 2024 15:39:09 GMT</pubDate></item><item><title><![CDATA[多播]]></title><description><![CDATA[发送范围：多播是将数据包发送到一组特定的设备，而不是所有设备。这些设备订阅了一个特定的多播组，只有订阅了该组的设备才能接收到数据包。
目标：多播的目标是一组设备，而不是所有设备。多播地址范围通常是<a data-href="IPv4" href="https://rinodg.pages.dev/computer/computer-networking/ipv4.html#_0" class="internal-link" target="_self" rel="noopener nofollow">IPv4</a>的 224.0.0.0 到 239.255.255.255。
使用场景：多播用于向多个接收者发送数据而不需要所有设备都接收的场景，如视频会议、实时流媒体传输等。<br>
效率：相对于<a data-href="广播" href="https://rinodg.pages.dev/computer/computer-networking/广播.html#_0" class="internal-link" target="_self" rel="noopener nofollow">广播</a>，多播的效率更高，因为只有需要的设备才接收到数据包，减少了网络负载。]]></description><link>https://rinodg.pages.dev/computer/computer-networking/多播.html</link><guid isPermaLink="false">Computer/Computer Networking/多播.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 07 Jun 2024 15:38:52 GMT</pubDate></item><item><title><![CDATA[TCP]]></title><description><![CDATA[The most common transport layer is TCP or the transmission control protocol.TCP's job is to make sure that the data sent by an application at one end of the internet is correctly differ delivered in the right order to the application at the other end of the internet.
If the network layers drop some datagrams TCP will transmit them multiple times.The two computers have to cooperate to make sure that each byte in the stream eventually gets delivered, in its proper place in line, to the stream socket on the other side. They also have to tell each other how much data they are prepared to accept from the other computer, and make sure not to send more than the other side is willing to accept. All this is done using an agreed-upon scheme that was set down in 1981, called the Transmission Control Protocol, or TCP.（或称三路握手，three-way handshake）过程创建一个连接。在连接创建过程中，很多参数要被初始化，例如序号被初始化以保证按序传输和连接的强壮性。TCP连接的正常创建
一对终端同时初始化一个它们之间的连接是可能的。但通常是由一端（服务器端）打开一个套接字（socket）然后监听来自另一方（客户端）的连接，这就是通常所指的被动打开（passive open）。服务器端被被动打开以后，客户端就能开始创建主动打开（active open）。服务器端执行了listen函数后，就在服务器上创建起两个队列：SYN队列：存放完成了二次握手的结果。 队列长度由listen函数的参数backlog指定。
ACCEPT队列：存放完成了<a data-href="三次握手" href="https://rinodg.pages.dev/computer/computer-networking/三次握手.html#_0" class="internal-link" target="_self" rel="noopener nofollow">三次握手</a>的结果。队列长度由listen函数的参数backlog指定。<br><img alt="2023-03-17_17-11.webp" src="https://rinodg.pages.dev/assets/2023-03-17_17-11.webp" target="_self"><br>ref <a data-href="udp" href="https://rinodg.pages.dev/computer/computer-networking/udp.html#_0" class="internal-link" target="_self" rel="noopener nofollow">udp</a><br><a data-href="Window Sizes" href="https://rinodg.pages.dev/computer/computer-networking/window-sizes.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Window Sizes</a><br><a data-href="关闭连接" href="https://rinodg.pages.dev/computer/computer-networking/关闭连接.html#_0" class="internal-link" target="_self" rel="noopener nofollow">关闭连接</a>]]></description><link>https://rinodg.pages.dev/computer/computer-networking/tcp.html</link><guid isPermaLink="false">Computer/Computer Networking/TCP.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 07 Jun 2024 15:38:32 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/2023-03-17_17-11.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/2023-03-17_17-11.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[关闭连接]]></title><description><![CDATA[<img alt="Pasted image 20240528170902.png" src="https://rinodg.pages.dev/assets/pasted-image-20240528170902.png" target="_self">]]></description><link>https://rinodg.pages.dev/computer/computer-networking/关闭连接.html</link><guid isPermaLink="false">Computer/Computer Networking/关闭连接.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 28 May 2024 09:09:04 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/pasted-image-20240528170902.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/pasted-image-20240528170902.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[三次握手]]></title><description><![CDATA[三次握手协议的过程：
客户端（通过执行connect函数）向服务器端发送一个SYN包，请求一个主动打开。该包携带客户端为这个连接请求而设定的随机数A作为消息序列号。
服务器端收到一个合法的SYN包后，把该包放入SYN队列中；回送一个SYN/ACK。ACK的确认码应为A+1，SYN/ACK包本身携带一个随机产生的序号B。
客户端收到SYN/ACK包后，发送一个ACK包，该包的序号被设定为A+1，而ACK的确认码则为B+1。然后客户端的connect函数成功返回。当服务器端收到这个ACK包的时候，把请求帧从SYN队列中移出，放至ACCEPT队列中；这时accept函数如果处于阻塞状态，可以被唤醒，从ACCEPT队列中取出ACK包，重新创建一个新的用于双向通信的sockfd，并返回。
<img alt="2023-03-17_16-12.webp" src="https://rinodg.pages.dev/assets/2023-03-17_16-12.webp" target="_self">
如果服务器端接到了客户端发的SYN后回了SYN-ACK后客户端掉线了，服务器端没有收到客户端回来的ACK，那么，这个连接处于一个中间状态，既没成功，也没失败。于是，服务器端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻倍，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s才知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 63s，TCP才会断开这个连接。使用三个TCP参数来调整行为：tcp_synack_retries 减少重试次数；tcp_max_syn_backlog，增大SYN连接数；tcp_abort_on_overflow决定超出能力时的行为。“三次握手”的目的是“为了防止已失效的连接(connect)请求报文段传送到了服务端，因而产生错误”，也即为了解决“网络中存在延迟的重复分组”问题。例如：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client发出的一个新的连接请求。于是就向client发出确认报文段，同意创建连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就创建了。由于现在client并没有发出创建连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经创建，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求创建连接]]></description><link>https://rinodg.pages.dev/computer/computer-networking/三次握手.html</link><guid isPermaLink="false">Computer/Computer Networking/三次握手.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 28 May 2024 09:08:28 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/2023-03-17_16-12.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/2023-03-17_16-12.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Window Sizes]]></title><description><![CDATA[发送方要知道接收方的 window 大小]]></description><link>https://rinodg.pages.dev/computer/computer-networking/window-sizes.html</link><guid isPermaLink="false">Computer/Computer Networking/Window Sizes.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 28 May 2024 09:05:51 GMT</pubDate></item><item><title><![CDATA[PTR Record]]></title><description><![CDATA[The Pointer Record
The Pointer (PTR) record allows you to perform a reverse lookup by accepting an IP address and returning its corresponding domain name. Listing 2-6 shows the reverse lookup for 8.8.4.4.$ dig 4.4.8.8.in-addr.arpa. ptr
;QUESTION
1 4.4.8.8.in-addr.arpa. IN PTR
;ANSWER
4.4.8.8.in-addr.arpa. 21599 IN PTR 2google-public-dns-b.google.com.
-- snip --
]]></description><link>https://rinodg.pages.dev/computer/computer-networking/ptr-record.html</link><guid isPermaLink="false">Computer/Computer Networking/PTR Record.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 28 May 2024 08:12:35 GMT</pubDate></item><item><title><![CDATA[广播]]></title><description><![CDATA[<a data-href="多播" href="https://rinodg.pages.dev/computer/computer-networking/多播.html#_0" class="internal-link" target="_self" rel="noopener nofollow">多播</a>（Multicast）和广播（Broadcast）是两种用于在计算机网络中发送数据的通信方法，它们的主要区别在于数据的接收范围和目标。以下是两者的详细区别：
发送范围：
广播是将数据包发送到网络中的所有设备。所有在同一子网内的设备都能接收到广播数据包。
目标：广播的目标是所有设备。比如，地址为 255.255.255.255 的IPv4地址会将数据包发送到网络中所有设备。
使用场景：广播通常用于需要通知所有设备的场景，如地址解析协议（ARP），用于解析IP地址到MAC地址。
效率：由于所有设备都接收到数据包，所以效率较低，尤其在大型网络中，可能导致不必要的网络负载。
]]></description><link>https://rinodg.pages.dev/computer/computer-networking/广播.html</link><guid isPermaLink="false">Computer/Computer Networking/广播.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 28 May 2024 07:26:40 GMT</pubDate></item><item><title><![CDATA[子网]]></title><description><![CDATA[子网络或子网是IP网络的一个逻辑细分。将一个网络划分为两个或多个网络的做法称为子网。子网属于同一子网的计算机在其IP地址中使用相同的最重要的位组进行寻址。这导致IP地址在逻辑上被分为两个字段：网络号或路由前缀和其余字段或主机标识符。剩下的字段是一个特定主机或网络接口的标识符。对于IPv4，一个网络也可以用它的子网掩码或<a data-href="网络掩码" href="https://rinodg.pages.dev/computer/computer-networking/网络掩码.html#_0" class="internal-link" target="_self" rel="noopener nofollow">网络掩码</a>来描述，它是一个位掩码，当它通过位和操作应用于网络中的任何IP地址时，就会产生路由前缀。子网掩码也像IP地址一样用点-十进制符号表示。例如，前缀198.51.100.0/24将有子网掩码255.255.255.0。<br><img alt="Pasted image 20240527170802.png" src="https://rinodg.pages.dev/assets/pasted-image-20240527170802.png" target="_self">/24 指的是把前面24位作为 network id 后面是 host id]]></description><link>https://rinodg.pages.dev/computer/computer-networking/子网.html</link><guid isPermaLink="false">Computer/Computer Networking/子网.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 27 May 2024 09:08:41 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/pasted-image-20240527170802.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/pasted-image-20240527170802.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Database]]></title><description><![CDATA[表的列（垂直方向）称为字段
表的行（水平方向）称为记录“SQL基础教程（第2版） ([日] MICK) (Z-Library).pdf#page=42&amp;rect=182,52,516,218&amp;color=yellow” could not be found.<a data-tooltip-position="top" aria-label="SQL基础教程（第2版） ([日] MICK) (Z-Library).pdf > page=112&amp;annotation=5625R" data-href="SQL基础教程（第2版） ([日] MICK) (Z-Library).pdf#page=112&amp;annotation=5625R" href="https://rinodg.pages.dev/.html" class="internal-link" target="_self" rel="noopener nofollow">SQL基础教程（第2版） ([日] MICK) (Z-Library), p.93</a> GROUP BY 子 句的 书 写 位 置 也 有 严 格 要 求，一 定 要 写 在 FROM 语句之后（如果有 WHERE 子句的话需要写在 WHERE 子句之后）。 <br><a data-href="SQL 常见错误" href="https://rinodg.pages.dev/computer/database/sql-常见错误.html#_0" class="internal-link" target="_self" rel="noopener nofollow">SQL 常见错误</a><br><a data-href="Views" href="https://rinodg.pages.dev/computer/database/views.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Views</a><br><a data-href="Having &amp; Where" href="https://rinodg.pages.dev/computer/database/having-&amp;-where.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Having &amp; Where</a><br><a data-href="集合运算" href="https://rinodg.pages.dev/computer/database/集合运算.html#_0" class="internal-link" target="_self" rel="noopener nofollow">集合运算</a><br><a data-href="窗口函数" href="https://rinodg.pages.dev/000-fleeting/窗口函数.html" class="internal-link" target="_self" rel="noopener nofollow">窗口函数</a>]]></description><link>https://rinodg.pages.dev/computer/database/database.html</link><guid isPermaLink="false">Computer/Database/Database.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 11 May 2024 07:55:25 GMT</pubDate></item><item><title><![CDATA[CROSS JOIN]]></title><description><![CDATA[交叉联结是所有联结运算的基础
对满足相同规则的表进行交叉联结的集合运算符是 CROSS JOIN（笛卡儿积）内联结是交叉联结的一部分，“内”也可以理解为“包含在交叉联 结结果中的部分”。相反，外联结的“外”可以理解为“交叉联结结果 之外的部分”。]]></description><link>https://rinodg.pages.dev/computer/database/cross-join.html</link><guid isPermaLink="false">Computer/Database/CROSS JOIN.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 11 May 2024 07:49:35 GMT</pubDate></item><item><title><![CDATA[集合运算]]></title><description><![CDATA[<a data-href="联结（JOIN）" href="https://rinodg.pages.dev/computer/database/联结（join）.html#_0" class="internal-link" target="_self" rel="noopener nofollow">联结（JOIN）</a><br>
<a data-href="外联结（OUTER JOIN）" href="https://rinodg.pages.dev/computer/database/外联结（outer-join）.html#_0" class="internal-link" target="_self" rel="noopener nofollow">外联结（OUTER JOIN）</a><br>
<a data-href="CROSS JOIN" href="https://rinodg.pages.dev/computer/database/cross-join.html#_0" class="internal-link" target="_self" rel="noopener nofollow">CROSS JOIN</a>]]></description><link>https://rinodg.pages.dev/computer/database/集合运算.html</link><guid isPermaLink="false">Computer/Database/集合运算.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 11 May 2024 07:45:15 GMT</pubDate></item><item><title><![CDATA[外联结（OUTER JOIN）]]></title><link>https://rinodg.pages.dev/computer/database/外联结（outer-join）.html</link><guid isPermaLink="false">Computer/Database/外联结（OUTER JOIN）.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 11 May 2024 07:42:57 GMT</pubDate></item><item><title><![CDATA[联结（JOIN）]]></title><description><![CDATA[“SQL基础教程（第2版） ([日] MICK) (Z-Library).pdf#page=255&amp;rect=150,178,480,491” could not be found.]]></description><link>https://rinodg.pages.dev/computer/database/联结（join）.html</link><guid isPermaLink="false">Computer/Database/联结（JOIN）.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 08 May 2024 02:10:37 GMT</pubDate></item><item><title><![CDATA[Having & Where]]></title><description><![CDATA[HAVING 和 WHERE 是 SQL 中用于筛选数据的两个关键字，它们的主要区别在于它们应用的时机和作用范围。 WHERE 子句用于在检索数据之前对行进行筛选，它在 SELECT 语句中出现在 FROM 子句之后，GROUP BY 子句之前。
SELECT column1, column2
FROM table_name
WHERE condition; HAVING 子句用于在对分组的结果应用条件进行筛选，它出现在 GROUP BY 子句之后，ORDER BY 子句之前。
SELECT column1, COUNT(*)
FROM table_name
GROUP BY column1
HAVING COUNT(*) &gt; 1; 基本上，WHERE 用于过滤行，而 HAVING 用于过滤分组。]]></description><link>https://rinodg.pages.dev/computer/database/having-&amp;-where.html</link><guid isPermaLink="false">Computer/Database/Having &amp; Where.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 30 Apr 2024 07:01:49 GMT</pubDate></item><item><title><![CDATA[SQL  常见错误]]></title><description><![CDATA[“SQL基础教程（第2版） ([日] MICK) (Z-Library).pdf#page=116&amp;rect=178,66,510,287&amp;color=yellow” could not be found.<a data-tooltip-position="top" aria-label="SQL基础教程（第2版） ([日] MICK) (Z-Library).pdf > page=173&amp;selection=59,0,61,2&amp;color=red" data-href="SQL基础教程（第2版） ([日] MICK) (Z-Library).pdf#page=173&amp;selection=59,0,61,2&amp;color=red" href="https://rinodg.pages.dev/.html" class="internal-link" target="_self" rel="noopener nofollow">SQL基础教程（第2版） ([日] MICK) (Z-Library), p.154</a> 视图的限制① ——定义视图时不能使用ORDER BY子句 因为视图跟表中的数据一样，没有顺序
<br><a data-tooltip-position="top" aria-label="SQL基础教程（第2版） ([日] MICK) (Z-Library).pdf > page=176&amp;selection=70,1,76,15&amp;color=yellow" data-href="SQL基础教程（第2版） ([日] MICK) (Z-Library).pdf#page=176&amp;selection=70,1,76,15&amp;color=yellow" href="https://rinodg.pages.dev/.html" class="internal-link" target="_self" rel="noopener nofollow">SQL基础教程（第2版） ([日] MICK) (Z-Library), p.157</a> 意事项由于 PostgreSQL 中的视图会被初始设定为只读，所以执行代码清单 5-6 中的 INSERT 语句时，会发生下面这样的错误。 ]]></description><link>https://rinodg.pages.dev/computer/database/sql-常见错误.html</link><guid isPermaLink="false">Computer/Database/SQL  常见错误.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 29 Apr 2024 08:41:09 GMT</pubDate></item><item><title><![CDATA[Views]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="SQL基础教程（第2版） ([日] MICK) (Z-Library).pdf > page=168&amp;selection=18,0,28,1&amp;color=yellow" data-href="SQL基础教程（第2版） ([日] MICK) (Z-Library).pdf#page=168&amp;selection=18,0,28,1&amp;color=yellow" href="https://rinodg.pages.dev/.html" class="internal-link" target="_self" rel="noopener nofollow">SQL基础教程（第2版） ([日] MICK) (Z-Library), p.149</a> 从 SQL 的角度来看，视图和表是相同的，两者的区别在于表中保存的是实际的数据，而视图中保存的是 SELECT 语句（视图本身并不存储数据）。 ]]></description><link>https://rinodg.pages.dev/computer/database/views.html</link><guid isPermaLink="false">Computer/Database/Views.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 29 Apr 2024 06:54:34 GMT</pubDate></item><item><title><![CDATA[zed 用 ollama]]></title><description><![CDATA[Here is a complete rundown of how I got it to work after collecting all the pieces of information in this thread:
Note: I run Ollama on Mac, if you run anything differently, you have to adapt it.
Add the following configuration to Zed config:
"assistant": { "version": "1", "provider": { "name": "openai", "type": "openai", "default_model": "gpt-4-turbo-preview", "api_url": "http://localhost:11434/v1" } } Download Mistral via ollama cli:
ollama run mistral Copy the downloaded Mistral, changing its name:
ollama cp mistral gpt-4-turbo-preview Add the OpenAI API key to Zed (<a data-tooltip-position="top" aria-label="https://ollama.com/blog/openai-compatibility" rel="noopener nofollow" class="external-link is-unresolved" href="https://ollama.com/blog/openai-compatibility" target="_self">source</a>):
ollama Restart Zed to ensure everything is working as it is supposed to.
]]></description><link>https://rinodg.pages.dev/uncategorized/zed-用-ollama.html</link><guid isPermaLink="false">Uncategorized/zed 用 ollama.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 25 Apr 2024 18:49:43 GMT</pubDate></item><item><title><![CDATA[打包]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://wiki.archlinux.org/title/Makepkg#Building_optimized_binaries" target="_self">https://wiki.archlinux.org/title/Makepkg#Building_optimized_binaries</a>
看来这是arch编译时期的魔法呢]]></description><link>https://rinodg.pages.dev/linux/打包.html</link><guid isPermaLink="false">Linux/打包.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 23 Apr 2024 19:52:23 GMT</pubDate></item><item><title><![CDATA[Arch]]></title><description><![CDATA[<a data-href="打包" href="https://rinodg.pages.dev/linux/打包.html#_0" class="internal-link" target="_self" rel="noopener nofollow">打包</a>]]></description><link>https://rinodg.pages.dev/linux/arch.html</link><guid isPermaLink="false">Linux/Arch.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 23 Apr 2024 19:52:06 GMT</pubDate></item><item><title><![CDATA[Django]]></title><description><![CDATA[<a data-href="migration" href="https://rinodg.pages.dev/.html" class="internal-link" target="_self" rel="noopener nofollow">migration</a>
一个 model 像是一张表<br>
<a data-href="Django 分页" href="https://rinodg.pages.dev/dev/django/django-分页.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Django 分页</a>]]></description><link>https://rinodg.pages.dev/dev/django/django.html</link><guid isPermaLink="false">Dev/Django/Django.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 17 Apr 2024 06:59:38 GMT</pubDate></item><item><title><![CDATA[Server-Sent Events (SSE) 和 WebSockets]]></title><description><![CDATA[Server-Sent Events (SSE) 和 WebSockets 都是用于在客户端和服务器之间实现实时通信的技术，但它们有几个关键区别： 双向通信 vs 单向通信： WebSockets：提供了全双工通信，客户端和服务器可以同时发送和接收消息。
SSE：是单向通信，只允许服务器向客户端推送数据，客户端无法向服务器发送消息。 协议： WebSockets 使用自定义的协议，在建立连接后，数据可以以任何格式进行传输。
SSE 使用基于 HTTP 的协议，使用简单的文本格式进行数据传输，即便是基于 HTTP，SSE 也是通过一个长期保持打开的 HTTP 连接来实现推送。 浏览器兼容性： WebSockets 在现代浏览器中得到了广泛支持，但在某些古老的浏览器版本中可能不受支持。
SSE 在大多数现代浏览器中都得到了支持，但与 WebSockets 相比，它的兼容性略差一些。 应用场景： WebSockets 通常用于需要双向通信的实时应用，如聊天应用、在线游戏等。
SSE 适用于服务器向客户端推送事件的场景，如实时更新的新闻、股票报价、日志更新等。 性能开销： WebSockets 通常需要维护长期的连接，因此可能会产生较大的性能开销，特别是在大规模并发连接的情况下。
SSE 使用简单的 HTTP 长连接，通常比 WebSockets 拥有更低的性能开销，特别适用于需要向大量客户端推送相对较少更新的场景。 综上所述，选择使用哪种技术取决于应用的具体需求。如果需要双向通信和较高的实时性，可以选择 WebSockets；如果只需服务器向客户端单向推送数据，并且希望更简单地实现，可以考虑使用 SSE。]]></description><link>https://rinodg.pages.dev/dev/web/server-sent-events-(sse)-和-websockets.html</link><guid isPermaLink="false">Dev/web/Server-Sent Events (SSE) 和 WebSockets.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 04 Mar 2024 08:47:26 GMT</pubDate></item><item><title><![CDATA[linux 共享库]]></title><description><![CDATA[SO-NAME对于新的系统来说，包括Solaris和Linux，普遍采用一种叫做SO-NAME的命名机制来记录共享库的依赖关系。每个共享库都有一个对应的“SO-NAME”，这个SO-NAME即共享库的文件名去掉次版本号和发布版本号，保留主版本号。比如一个共享库叫做libfoo.so.2.6.1，那么它的SO-NAME即libfoo.so.2。比如系统中有存在一个共享库“/lib/libfoo.so.2.6.1”，那么Linux中的共享库管理程序就会为它产生一个软链接“/lib/libfoo.so.2”指向它。$ ls -l /lib/libc*
-rwxr-xr-x 1 root root 1249520 2007-10-25 09:03 libc-2.6.1.so
…
lrwxrwxrwx 1 root root 13 2007-11-10 15:49 libc.so.6 -&gt; libc-2.6.1.so
…
]]></description><link>https://rinodg.pages.dev/computer/linux-共享库.html</link><guid isPermaLink="false">Computer/linux 共享库.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 25 Jan 2024 14:56:04 GMT</pubDate></item><item><title><![CDATA[ABI]]></title><link>https://rinodg.pages.dev/computer/abi.html</link><guid isPermaLink="false">Computer/ABI.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 25 Jan 2024 14:50:35 GMT</pubDate></item><item><title><![CDATA[Bus]]></title><description><![CDATA[早期的计算机没有很复杂的图形功能，CPU的核心频率也不高，跟内存的频率一样，它们都是直接连接在同一个总线（Bus）上的。CPU核心频率的提升，导致内存跟不上CPU的速度，于是产生了与内存频率一致的系统总线慢速的I/O总线已经无法满足图形设备的巨大需求。为了协调CPU、内存和高速的图形设备，人们专门设计了一个高速的北桥芯片，以便它们之间能够高速地交换数据。由于北桥运行的速度非常高，所有相对低速的设备如果全都直接连接在北桥上，北桥既须处理高速设备，又须处理低速设备，设计就会十分复杂。于是人们又设计了专门处理低速设备的南桥（Southbridge）芯片，磁盘、USB、键盘、鼠标等设备都连接在南桥上，由南桥将它们汇总后连接到北桥上。 2024 年南北桥都消失了，集成在了cpu]]></description><link>https://rinodg.pages.dev/computer/bus.html</link><guid isPermaLink="false">Computer/Bus.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 24 Jan 2024 15:47:04 GMT</pubDate></item><item><title><![CDATA[grpc]]></title><description><![CDATA[gRPC是一种开源的远程过程调用（RPC）框架，由Google开发。它使用Protocol Buffers作为接口描述语言，提供了高效、跨语言的通信机制。gRPC支持多种编程语言，并且具有强大的功能，如双向流、流控制和多语言支持。这使得它成为构建分布式系统的强大工具。]]></description><link>https://rinodg.pages.dev/dev/grpc.html</link><guid isPermaLink="false">Dev/grpc.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 08 Jan 2024 13:25:35 GMT</pubDate></item><item><title><![CDATA[整数运算]]></title><description><![CDATA[乘法可以用左移实现]]></description><link>https://rinodg.pages.dev/computer/整数运算.html</link><guid isPermaLink="false">Computer/整数运算.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 04 Dec 2023 02:47:21 GMT</pubDate></item><item><title><![CDATA[整数表示]]></title><description><![CDATA[ 无符号整数（Unsigned Integer）： 无符号整数只包含非负整数，不包括负数或零。
在计算机中，无符号整数通常用二进制表示，可以直接对应非负的十进制整数。
例如，8位无符号整数的范围是0到255（11111111二进制为255）。 有符号整数（Signed Integer）： 有符号整数包含正数、负数和零。
通常使用其中一位来表示符号，而其他位表示数值。常见的表示方式有原码、反码和补码。 补码（Two's Complement）： <a data-href="补码" href="https://rinodg.pages.dev/computer/computer-architecture/补码.html#_0" class="internal-link" target="_self" rel="noopener nofollow">补码</a>是计算机中表示有符号整数的常用方式。
正数的补码与原码相同，负数的补码是其绝对值的二进制表示按位取反后加1。
补码有一个优势，即加法和减法可以在不考虑符号位的情况下使用相同的硬件电路进行，简化了运算过程。 转换 扩展不会又精度损失
缩小会对大的做取模运算 <br><a data-href="整数运算" href="https://rinodg.pages.dev/computer/整数运算.html#_0" class="internal-link" target="_self" rel="noopener nofollow">整数运算</a>]]></description><link>https://rinodg.pages.dev/computer/computer-architecture/整数表示.html</link><guid isPermaLink="false">Computer/Computer Architecture/整数表示.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 04 Dec 2023 02:46:53 GMT</pubDate></item><item><title><![CDATA[补码]]></title><description><![CDATA[ChatGPT补码是一种用于在计算机中表示有符号整数的方式，其工作原理如下：
正数的表示： 对于正整数，补码与二进制原码相同。
例如，十进制数+5的二进制原码是00000101，它的补码也是00000101。 负数的表示： 对于负整数，补码的表示稍显复杂。
负数的补码是其绝对值的二进制表示按位取反后加1。
例如，十进制数-5的绝对值是5，其二进制表示是00000101，取反后得到11111010，然后再加1得到补码为11111011。
最小的数为 1000000
所有二进制数是1，表示 -1 加法操作： 补码的一个关键特性是，在加法运算中，无需特别处理符号位。正数和负数的加法使用相同的硬件电路。
溢出时，溢出的位被丢弃，不会影响结果的正确性。 减法操作： 通过将减法转化为加法，补码简化了计算机中的减法运算。
减法可以通过将减数的补码加到被减数的补码，再处理可能的溢出得到正确结果。 ]]></description><link>https://rinodg.pages.dev/computer/computer-architecture/补码.html</link><guid isPermaLink="false">Computer/Computer Architecture/补码.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 29 Nov 2023 10:26:16 GMT</pubDate></item><item><title><![CDATA[Hex and Decimal]]></title><description><![CDATA[ i 余数
j 商 = 0x800<img alt="Hex and Decimal-1701246586199.jpeg" src="https://rinodg.pages.dev/assets/image/hex-and-decimal-1701246586199.jpeg" target="_self">]]></description><link>https://rinodg.pages.dev/computer/computer-architecture/hex-and-decimal.html</link><guid isPermaLink="false">Computer/Computer Architecture/Hex and Decimal.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 29 Nov 2023 08:30:25 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/image/hex-and-decimal-1701246586199.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/image/hex-and-decimal-1701246586199.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Elixir]]></title><description><![CDATA[In Elixir, all datatypes evaluate to a truthy or falsy value when they are encountered in a boolean context (like an if expression). All data is considered truthy except for false and nil. In particular, empty strings, the integer 0, and empty lists are all considered truthy in Elixir.]]></description><link>https://rinodg.pages.dev/computer/programming/elixir.html</link><guid isPermaLink="false">Computer/Programming/Elixir.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 06 Nov 2023 06:42:13 GMT</pubDate></item><item><title><![CDATA[202204231534]]></title><description><![CDATA[”<a data-tooltip-position="top" aria-label="https://stackoverflow.com/questions/38636343/what-is-the-difference-between-execution-and-evaluation" rel="noopener nofollow" class="external-link is-unresolved" href="https://stackoverflow.com/questions/38636343/what-is-the-difference-between-execution-and-evaluation" target="_self">c - What is the difference between execution and evaluation? - Stack Overflow</a>It's just a matter of linguistics. Expressions are evaluated, statements are executed. In both cases we can say that "something gets done", and I wouldn't worry too much about the difference.To clarify: roughly, a statement is a line of code, and an expression is what you can find between brackets in an if() or while(), or on the right side of an equal sign.For example, int x = 2 + 3; is a statement that declares a variable x and assigns to it the result of the expression 2 + 3, that is, 5. ]]></description><link>https://rinodg.pages.dev/computer/cs61a/202204231534.html</link><guid isPermaLink="false">Computer/CS61A/202204231534.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 28 Oct 2023 10:53:35 GMT</pubDate></item><item><title><![CDATA[zsh disable history]]></title><description><![CDATA[Launch a new zsh shell and disable history within it.
Option 1zsh # or just $SHELL if you're already running zsh
unset HISTFILE
...secret commands...
exitThe secret commands won't be stored in the history file.
Option 2zsh # or just $SHELL if you're already running zsh
fc -p
...secret commands...
exitThe fc -p will switch zsh to a in-memory history that will be discarded when you exit.The downside: the previous history (commands entered before the private session started) will not be available.]]></description><link>https://rinodg.pages.dev/linux/zsh-disable-history.html</link><guid isPermaLink="false">Linux/zsh disable history.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 15 Sep 2023 10:58:12 GMT</pubDate></item><item><title><![CDATA[index db]]></title><description><![CDATA[当涉及到 IndexedDB 和加密的 Web Storage，使用 Svelte 可能会涉及到更多的 JavaScript 代码。我将为你提供一个使用 Svelte 和 IndexedDB 来存储和检索密码的示例：首先，在你的 Svelte 组件中，你可以创建一个 IndexedDB 数据库并定义存储密码的对象存储空间。以下是一个基本的示例：&lt;script&gt; import { onMount } from 'svelte'; let password = ''; onMount(() =&gt; { const dbName = 'passwordsDB'; const storeName = 'passwords'; const request = window.indexedDB.open(dbName, 1); request.onupgradeneeded = (event) =&gt; { const db = event.target.result; db.createObjectStore(storeName, { keyPath: 'id', autoIncrement: true }); }; request.onsuccess = (event) =&gt; { const db = event.target.result; const transaction = db.transaction(storeName, 'readwrite'); const objectStore = transaction.objectStore(storeName); // 存储密码 const addRequest = objectStore.add({ password }); addRequest.onsuccess = () =&gt; { console.log('密码已存储'); }; addRequest.onerror = () =&gt; { console.error('密码存储错误'); }; // 检索密码 const getRequest = objectStore.get(1); getRequest.onsuccess = (event) =&gt; { const result = event.target.result; if (result) { console.log('检索到密码:', result.password); } else { console.log('未找到密码'); } }; getRequest.onerror = () =&gt; { console.error('密码检索错误'); }; transaction.oncomplete = () =&gt; { db.close(); }; }; request.onerror = () =&gt; { console.error('数据库打开错误'); }; });
&lt;/script&gt; &lt;input bind:value={password} placeholder="输入密码" /&gt;
在这个示例中，我们使用 window.indexedDB.open() 方法来打开一个名为 passwordsDB 的 IndexedDB 数据库，并在 onupgradeneeded 事件中创建一个名为 passwords 的对象存储空间。通过 request.onsuccess 事件处理函数，我们获取到数据库实例并创建一个事务，在事务中访问 passwords 对象存储空间。我们使用 objectStore.add() 方法将密码存储到 IndexedDB 中，并使用 objectStore.get() 方法检索密码。这里我们使用了一个简单的自增的 id 属性来演示检索密码的示例。你可以根据你的需求进行更多操作，如更新密码、删除密码等。请注意，上述示例仅用于演示基本的 IndexedDB 操作和密码存储。在实际应用中，你需要根据你的具体需求和安全性要求来设计和实现更复杂的逻辑以保护密码和用户数据的安全。]]></description><link>https://rinodg.pages.dev/computer/database/index-db.html</link><guid isPermaLink="false">Computer/Database/index db.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 02 Sep 2023 16:50:08 GMT</pubDate></item><item><title><![CDATA[Django 初始化自带数据]]></title><description><![CDATA[有多种方法可以在 Django migrate 初始化数据库时自带数据，以下是其中一些常见的方法：使用 fixtures
在 Django 中，可以使用 fixtures 来提供初始数据。Fixture 是一个包含初始模型数据的文件，通常是 JSON 或 YAML 格式。您可以在模型中定义好数据，然后使用 Django 的 dumpdata 命令将其导出为 fixture 文件。在应用程序的 migrations 目录中，创建一个名为 initial_data 的 fixture 文件，Django 将在每次运行 migrate 命令时自动加载它。编写数据迁移脚本
您可以编写一个 Django 数据迁移脚本来插入初始数据。在应用程序的 migrations 目录中，创建一个数据迁移脚本，使用 RunPython 操作来插入数据。例如：from django.db import migrations def insert_initial_data(apps, schema_editor): MyModel = apps.get_model('myapp', 'MyModel') MyModel.objects.create(name='John', age=30) MyModel.objects.create(name='Jane', age=25) class Migration(migrations.Migration): dependencies = [ ('myapp', '0001_initial'), ] operations = [ migrations.RunPython(insert_initial_data), ]
使用 Django Seed
Django Seed 是一个 Django 应用程序，可以从 CSV 或 JSON 文件中加载数据，并将其插入到数据库中。您可以在应用程序的 migrations 目录中创建一个数据迁移脚本，使用 Django Seed 来插入数据。例如：from django.db import migrations
from django_seed import Seed def insert_initial_data(apps, schema_editor): MyModel = apps.get_model('myapp', 'MyModel') seeder = Seed.seeder() seeder.add_entity(MyModel, 10) seeder.execute() class Migration(migrations.Migration): dependencies = [ ('myapp', '0001_initial'), ] operations = [ migrations.RunPython(insert_initial_data), ]
]]></description><link>https://rinodg.pages.dev/dev/django/django-初始化自带数据.html</link><guid isPermaLink="false">Dev/Django/Django 初始化自带数据.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 12 Jul 2023 00:40:00 GMT</pubDate></item><item><title><![CDATA[Django 分页]]></title><description><![CDATA[• 如果你想要使用Django自带的Paginator类来实现分页，你可以参考Django官方文档 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.djangoproject.com/en/4.2/topics/pagination/" target="_self">https://docs.djangoproject.com/en/4.2/topics/pagination/</a> 中的例子。你需要在你的视图中创建一个Paginator对象，传入你要分页的对象列表和每页的数量，然后根据请求参数获取对应的Page对象，将其传递给模板。在模板中，你可以使用page_obj来访问当前页的对象列表、页码、是否有上一页或下一页等属性。你还可以使用page_obj.paginator来访问总页数、总对象数等属性。你可以使用类似于你提供的代码来显示上一页和下一页的链接，也可以显示所有页码或者省略一些页码，具体可以参考文档中的例子。<br>• 如果你想要使用Django自带的ListView类来实现分页，你可以参考Real Python网站上的教程 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://realpython.com/django-pagination/" target="_self">https://realpython.com/django-pagination/</a> 。你只需要在你的ListView子类中设置一个paginate_by属性，指定每页的数量，然后Django会自动为你提供一个paginator和page_obj对象。在模板中，你可以使用和上面相同的方法来显示分页相关的信息和链接。<br>• 如果你想要使用Django REST framework来实现分页，你可以参考Django REST framework官方文档 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.django-rest-framework.org/api-guide/pagination/" target="_self">https://www.django-rest-framework.org/api-guide/pagination/</a> 中的例子。你需要在你的settings.py文件中设置一个REST_FRAMEWORK字典，指定一个DEFAULT_PAGINATION_CLASS和一个PAGE_SIZE。然后Django REST framework会自动为你提供一个paginator和page对象。在模板中，你可以使用page来访问当前页的数据和分页相关的信息，也可以使用paginator来访问总页数、总数据数等属性。你还可以使用不同的分页样式，比如基于数字、基于游标、基于限制-偏移等。]]></description><link>https://rinodg.pages.dev/dev/django/django-分页.html</link><guid isPermaLink="false">Dev/Django/Django 分页.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 06 Jul 2023 08:01:12 GMT</pubDate></item><item><title><![CDATA[spring web]]></title><description><![CDATA[<img alt="spring web-1685289945837.jpeg" src="https://rinodg.pages.dev/assets/image/spring-web-1685289945837.jpeg" target="_self">]]></description><link>https://rinodg.pages.dev/computer/web-applications/spring-web.html</link><guid isPermaLink="false">Computer/Web Applications/spring web.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sun, 28 May 2023 16:11:08 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/image/spring-web-1685289945837.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/image/spring-web-1685289945837.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[smart point]]></title><description><![CDATA[
来自 Chatgpt 的解释 在智能指针 Rc&lt;T&gt; 的引用计数为 0 时，对象就会被清除。因此，如果一个对象只被弱引用指向，它就会被回收。 weak_count 就是指弱引用的数量，它表示对象的引用计数是否为 0，这对于判断对象是否被回收很有用。 通过使用 Weak&lt;T&gt; 和 Rc&lt;T&gt;，你可以实现循环引用，这样就不会因为内存泄露而导致程序崩溃。在 Rust 中，强引用的数量是固定的，并且在编译时就能确定。但是，弱引用的数量是不固定的，因此通过使用弱引用可以避免内存泄露。 如果你不使用 Weak&lt;T&gt; 而直接使用 Rc&lt;T&gt;，那么引用计数会增加，并且引用的对象永远不会被清除。这很可能会导致内存泄露，因为如果你在某些地方创建了循环引用，那么引用的对象永远不会被清除，进而导致内存不断增加。 为了避免这种情况，你需要使用 Weak&lt;T&gt; 来指向对象，这样在没有强引用指向对象时它就可以被清除。这样可以避免内存泄露，同时还能使程序更加高效。 ]]></description><link>https://rinodg.pages.dev/computer/programming/rust/smart-point.html</link><guid isPermaLink="false">Computer/Programming/Rust/smart point.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 07 Apr 2023 15:03:10 GMT</pubDate></item><item><title><![CDATA[udp]]></title><description><![CDATA[udp is an alternative transport layer that bundles up application data and hands it to the network layer for delivery to the other endhands it to the network layer for delivery to the other end. udp offers no delivery guarantees at all.<img alt="udp-1679050115511.jpeg" src="https://rinodg.pages.dev/assets/image/udp-1679050115511.jpeg" target="_self"><br><img alt="udp-1679051130778.jpeg" src="https://rinodg.pages.dev/assets/image/udp-1679051130778.jpeg" target="_self">]]></description><link>https://rinodg.pages.dev/computer/computer-networking/udp.html</link><guid isPermaLink="false">Computer/Computer Networking/udp.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 17 Mar 2023 11:05:36 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/image/udp-1679050115511.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/image/udp-1679050115511.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Internet Protocol]]></title><description><![CDATA[<img alt="Internet Protocol-1677847475053.jpeg" src="https://rinodg.pages.dev/assets/image/internet-protocol-1677847475053.jpeg" target="_self"> <a data-href="IPv4" href="https://rinodg.pages.dev/computer/computer-networking/ipv4.html#_0" class="internal-link" target="_self" rel="noopener nofollow">IPv4</a>
We must use the Internet Protocol(IP)
IP makes a best-effort attempt to deliver our datagrams to the other end. But it makes no promises.
IP datagrams can get lost, can be delivered out of order, and can be corrupted. There are no guarantees.
IP service is so simple
simple dumb and minimal Faster, more streamlined and lower cost to build and maintain. the end-to-end principle Where possible, implement features in the end hosts. <br>Tries to prevent <a data-href="packet" href="https://rinodg.pages.dev/computer/computer-networking/packet.html#_0" class="internal-link" target="_self" rel="noopener nofollow">packet</a> looping forever.(TTL)
<br>Will fragment <a data-href="packet" href="https://rinodg.pages.dev/computer/computer-networking/packet.html#_0" class="internal-link" target="_self" rel="noopener nofollow">packet</a> if they too long.(<a data-href="MTU" href="https://rinodg.pages.dev/computer/computer-networking/mtu.html#_0" class="internal-link" target="_self" rel="noopener nofollow">MTU</a>)
Uses a header checksum to reduce chances of delivering datagram to wrong destination
Allows for new versions of IP(v4 and v6)
Allows fro new options to be added to header
]]></description><link>https://rinodg.pages.dev/computer/computer-networking/internet-protocol.html</link><guid isPermaLink="false">Computer/Computer Networking/Internet Protocol.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 14 Mar 2023 13:53:56 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/image/internet-protocol-1677847475053.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/image/internet-protocol-1677847475053.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ICE]]></title><description><![CDATA[交互式连接创建（Interactive Connectivity Establishment），一种综合性的NAT穿越的技术。交互式连接创建是由IETF的MMUSIC工作组开发出来的一种framework，可集成各种NAT穿透技术，如STUN、TURN（Traversal Using Relay NAT，中继NAT实现的穿透）、RSIP（Realm Specific IP，特定域IP）等。该framework可以让SIP的客户端利用各种NAT穿透方式打穿远程的防火墙。 <a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols" target="_self">https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Protocols</a> ]]></description><link>https://rinodg.pages.dev/computer/computer-networking/ice.html</link><guid isPermaLink="false">Computer/Computer Networking/ICE.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 14 Mar 2023 13:53:44 GMT</pubDate></item><item><title><![CDATA[TUN and TAP]]></title><description><![CDATA[In <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Computer_networking" rel="noopener nofollow" class="external-link is-unresolved" title="Computer networking" href="https://en.wikipedia.org/wiki/Computer_networking" target="_self">computer networking</a>, TUN and TAP are <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Kernel_(computer_science)" rel="noopener nofollow" class="external-link is-unresolved" title="Kernel (computer science)" href="https://en.wikipedia.org/wiki/Kernel_(computer_science)" target="_self">kernel</a> <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Virtual_network" rel="noopener nofollow" class="external-link is-unresolved" title="Virtual network" href="https://en.wikipedia.org/wiki/Virtual_network" target="_self">virtual network</a> devices. Being network devices supported entirely in software, they differ from ordinary network devices which are backed by physical <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Network_adapter" rel="noopener nofollow" class="external-link is-unresolved" title="Network adapter" href="https://en.wikipedia.org/wiki/Network_adapter" target="_self">network adapters</a>.<br><img alt="TUN TAP-1678176253048.jpeg" src="https://rinodg.pages.dev/assets/image/tun-tap-1678176253048.jpeg" target="_self">TUN无法与物理网卡做bridge，也没有MAC地址，但是可以通过三层交换与物理网卡连通。<br>
TAP可以与物理网卡做<a data-href="bridge" href="https://rinodg.pages.dev/computer/computer-networking/bridge.html#_0" class="internal-link" target="_self" rel="noopener nofollow">bridge</a>，也有MAC地址，但是需要更多的资源和开销。]]></description><link>https://rinodg.pages.dev/computer/computer-networking/tun-and-tap.html</link><guid isPermaLink="false">Computer/Computer Networking/TUN and TAP.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 14 Mar 2023 05:34:16 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/image/tun-tap-1678176253048.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/image/tun-tap-1678176253048.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[ARP]]></title><description><![CDATA[ARP（Address Resolution Protocol，地址解析协议）是用来将IP地址解析为MAC地址的协议。主机或三层网络设备上会维护一张ARP表，用于存储IP地址和MAC地址的映射关系，一般ARP表项包括动态ARP表项和静态ARP表项。<img alt="ARP-1678698919522.jpeg" src="https://rinodg.pages.dev/assets/image/arp-1678698919522.jpeg" target="_self">
ARP协议是通过报文进行工作的，是一个独立的三层协议。当主机A要向主机B发送信息时，它首先查看自己的ARP缓存表，确定其中是否包含有主机B对应的ARP表项。如果找到了对应的MAC地址，则主机A直接利用ARP表中的MAC地址，对IP数据包进行帧封装，并将数据包发送给主机B。如果主机A在ARP表中找不到对应的MAC地址，则将缓存该数据报文，然后以广播方式发送一个ARP请求报文。]]></description><link>https://rinodg.pages.dev/computer/computer-networking/arp.html</link><guid isPermaLink="false">Computer/Computer Networking/ARP.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 13 Mar 2023 14:01:28 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/image/arp-1678698919522.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/image/arp-1678698919522.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[CIDR]]></title><link>https://rinodg.pages.dev/computer/computer-networking/cidr.html</link><guid isPermaLink="false">Computer/Computer Networking/CIDR.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 13 Mar 2023 08:10:32 GMT</pubDate></item><item><title><![CDATA[Longest prefix match]]></title><description><![CDATA[Algorithm IP routers use to chose matching entry from <a data-tooltip-position="top" aria-label="Forwarding information base" data-href="Forwarding information base" href="https://rinodg.pages.dev/computer/computer-networking/forwarding-information-base.html#_0" class="internal-link" target="_self" rel="noopener nofollow">forwarding table</a>
<br>Forwarding table is a set of <a data-href="CIDR" href="https://rinodg.pages.dev/computer/computer-networking/cidr.html#_0" class="internal-link" target="_self" rel="noopener nofollow">CIDR</a> entries An address might match multiple entries
E.g. 171.33.0.1 matches both entries on right • Algorithm: use forwarding entry with the longest matching prefix Longest prefix match will chose link 5 for 171.33.0.1 ]]></description><link>https://rinodg.pages.dev/computer/computer-networking/longest-prefix-match.html</link><guid isPermaLink="false">Computer/Computer Networking/Longest prefix match.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 13 Mar 2023 08:10:31 GMT</pubDate></item><item><title><![CDATA[Forwarding information base]]></title><description><![CDATA[转发信息库 (forwarding information base, FIB)，也称为转发表或 MAC 表，最常用于网络桥接、路由和类似功能，以找到输入接口应将数据包转发到的正确输出网卡。它是一个将 MAC 地址映射到端口的动态表。它是将网络交换机与集线器分开的基本机制。内容可寻址存储器(CAM) 通常用于高效地实现 FIB，因此有时也称为 CAM 表。]]></description><link>https://rinodg.pages.dev/computer/computer-networking/forwarding-information-base.html</link><guid isPermaLink="false">Computer/Computer Networking/Forwarding information base.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 13 Mar 2023 07:52:49 GMT</pubDate></item><item><title><![CDATA[Big Endian and Little Endian]]></title><description><![CDATA[All computers do not store the bytes that comprise a multi-byte value in the same order. Consider a 16-bit internet that is made up of 2 bytes. Two ways to store this value −
Little Endian − In this scheme, low-order byte is stored on the starting address (A) and high-order byte is stored on the next address (A + 1). make most sense from an addressing/computetational standpoint Big Endian − In this scheme, high-order byte is stored on the starting address (A) and low-order byte is stored on the next address (A + 1). make most sense to a human reader ]]></description><link>https://rinodg.pages.dev/computer/computer-architecture/big-endian-and-little-endian.html</link><guid isPermaLink="false">Computer/Computer Architecture/Big Endian and Little Endian.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 11 Mar 2023 07:58:26 GMT</pubDate></item><item><title><![CDATA[MTU]]></title><link>https://rinodg.pages.dev/computer/computer-networking/mtu.html</link><guid isPermaLink="false">Computer/Computer Networking/MTU.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 11 Mar 2023 07:10:43 GMT</pubDate></item><item><title><![CDATA[bridge]]></title><description><![CDATA[将虚拟网卡和物理网卡连接到一个虚拟交换机上，使它们可以在同一个网络层次上通信。
使虚拟网卡和物理网卡有相同的MAC地址，支持MAC层广播。
使虚拟网卡和物理网卡互相独立的IP，物理网卡监听这些IP。使用虚拟机软件，如VirtualBox，需要让虚拟机和主机在同一个网络层次上通信。
使用虚拟化桌面，需要让虚拟机和主机互相独立的IP。
使用Linux网络适配器，需要让虚拟网卡和物理网卡相互可以ping通。]]></description><link>https://rinodg.pages.dev/computer/computer-networking/bridge.html</link><guid isPermaLink="false">Computer/Computer Networking/bridge.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 10 Mar 2023 16:18:26 GMT</pubDate></item><item><title><![CDATA[underline in c++]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.doc.ic.ac.uk/lab/cplus/c++.rules/chap5.html" target="_self">https://www.doc.ic.ac.uk/lab/cplus/c++.rules/chap5.html</a>
The use of two underscores ( _ ) in identifiers is reserved for the compiler's internal use according to the ANSI-C standard.
Underscores ( ) are often used in names of library functions (such as "_main" and "_exit"). In order to avoid collisions, do not begin an identifier with an underscore.
]]></description><link>https://rinodg.pages.dev/computer/computer-networking/underline-in-c++.html</link><guid isPermaLink="false">Computer/Computer Networking/underline in c++.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sun, 05 Mar 2023 05:10:28 GMT</pubDate></item><item><title><![CDATA[CS144 lab1]]></title><description><![CDATA[StreamReassembler我为什么要这样做？在不同的不太可靠的服务之上提供服务或抽象是网络中许多有趣问题的原因。在过去的 40 年里，研究人员和从业者已经弄清楚了如何通过 Internet 传递各种信息——消息和电子邮件、超链接文档、搜索引擎、声音和视频、虚拟世界、协作文件共享、数字货币。 TCP 自身的作用，即使用不可靠的数据报提供一对可靠的字节流，就是这方面的经典示例之一。一个合理的观点是，TCP 实现算作地球上使用最广泛的非平凡计算机程序。实验室作业将要求您以模块化方式构建 TCP 实现。还记得您刚刚在 Lab 0 中实现的 ByteStream 吗？在接下来的四个实验中，您将最终通过网络传送其中两个：一个“出站”字节流，用于本地应用程序写入套接字并且您的 TCP 将发送给对等点的数据，以及一个“入站” ByteStream 用于来自对等点的数据，将由本地应用程序读取。图 1 显示了各个部分如何组合在一起The TCP sender is dividing its byte stream up into short segments (substrings no more than about 1,460 bytes apiece) so that they each fit inside a datagram. But the network might reorder these datagrams, or drop them, or deliver them more than once. The receiver must reassemble the segments into the contiguous stream of bytes that they started out as在本实验中，您将编写负责此重组的数据结构：StreamReassembler。它将接收子字符串，由字节字符串和较大流中该字符串的第一个字节的索引组成。流的每个字节都有自己唯一的索引，Each byte of the stream has its own unique index，从零开始向上计数。 StreamReassembler 将拥有一个用于输出的 ByteStream：一旦重组器知道流的下一个字节，它就会将其写入 ByteStream。所有者可以随时访问和读取 ByteStream。
<img alt="CS144 lab1-1677946921891.jpeg" src="https://rinodg.pages.dev/assets/image/cs144-lab1-1677946921891.jpeg" target="_self">]]></description><link>https://rinodg.pages.dev/computer/computer-networking/cs144-lab1.html</link><guid isPermaLink="false">Computer/Computer Networking/CS144 lab1.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 04 Mar 2023 16:22:07 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/image/cs144-lab1-1677946921891.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/image/cs144-lab1-1677946921891.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[IPv4]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://zh.wikipedia.org/wiki/IPv4" target="_self">https://zh.wikipedia.org/wiki/IPv4</a>
网络编码是一种通过中继节点对接收到的信息进行编码来达到提高多播网络容量的技术。Rudolf Ahlswede, Ning Cai, Shuo-Yen Robert Li, Raymond W. Yeung[1]在2000年首次提出网络编码的概念。<br><a data-href="网络掩码" href="https://rinodg.pages.dev/computer/computer-networking/网络掩码.html#_0" class="internal-link" target="_self" rel="noopener nofollow">网络掩码</a>告诉你哪个 IP地址是同一网络中同一链路上的本地地址，]]></description><link>https://rinodg.pages.dev/computer/computer-networking/ipv4.html</link><guid isPermaLink="false">Computer/Computer Networking/IPv4.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 14:51:53 GMT</pubDate></item><item><title><![CDATA[Computer Networking]]></title><description><![CDATA[<a data-href="Internet Protocol" href="https://rinodg.pages.dev/computer/computer-networking/internet-protocol.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Internet Protocol</a><br>
<a data-href="TCP" href="https://rinodg.pages.dev/computer/computer-networking/tcp.html#_0" class="internal-link" target="_self" rel="noopener nofollow">TCP</a><br>
<a data-href="Packet Switching" href="https://rinodg.pages.dev/computer/computer-networking/packet-switching.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Packet Switching</a><br>learned to <a data-href="Encapsulation" href="https://rinodg.pages.dev/computer/computer-networking/encapsulation.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Encapsulation</a>]]></description><link>https://rinodg.pages.dev/computer/computer-networking/computer-networking.html</link><guid isPermaLink="false">Computer/Computer Networking/Computer Networking.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 14:37:23 GMT</pubDate></item><item><title><![CDATA[Encapsulation]]></title><description><![CDATA[<img alt="Encapsulation (networking)-1677852705096.jpeg" src="https://rinodg.pages.dev/assets/image/encapsulation-(networking)-1677852705096.jpeg" target="_self">
在计算机网络中，封装是一种设计模块化通信协议的方法，其中通过包含或信息隐藏在更高级别的对象中，将网络中逻辑上分离的功能从其底层结构中抽象出来。换句话说，封装“从更高层获取信息并向其添加标头，将更高层信息视为数据”。<br>
<img alt="Encapsulation-1677852825322.jpeg" src="https://rinodg.pages.dev/assets/image/encapsulation-1677852825322.jpeg" target="_self">
in hardware, first bit on right<br><img alt="Encapsulation-1677853941070.jpeg" src="https://rinodg.pages.dev/assets/image/encapsulation-1677853941070.jpeg" target="_self">]]></description><link>https://rinodg.pages.dev/computer/computer-networking/encapsulation.html</link><guid isPermaLink="false">Computer/Computer Networking/Encapsulation.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 14:32:21 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/image/encapsulation-(networking)-1677852705096.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/image/encapsulation-(networking)-1677852705096.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Bellman-Ford]]></title><description><![CDATA[<a rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm" target="_self">https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://zh.wikipedia.org/zh-tw/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95" target="_self">https://zh.wikipedia.org/zh-tw/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95</a>Bellman-Ford algorithm is a single-source shortest path algorithm, so when you have negative edge weight then it can detect negative cycles in a graph.The only difference between the two is that Bellman-Ford is also capable of handling negative weights whereas Dijkstra Algorithm can only handle positives.]]></description><link>https://rinodg.pages.dev/computer/data-structure/bellman-ford.html</link><guid isPermaLink="false">Computer/Data Structure/Bellman-Ford.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 11:15:28 GMT</pubDate></item><item><title><![CDATA[Procedural Macros]]></title><description><![CDATA[The second form of macros is the procedural macro, which acts more like a function (and is a type of procedure). Procedural macros accept some code as an input, operate on that code, and produce some code as an output rather than matching against patterns and replacing the code with other code as declarative macros do. The three kinds of procedural macros are custom derive, attribute-like, and function-like, and all work in a similar fashion.]]></description><link>https://rinodg.pages.dev/computer/programming/rust/procedural-macros.html</link><guid isPermaLink="false">Computer/Programming/Rust/Procedural Macros.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 11:14:37 GMT</pubDate></item><item><title><![CDATA[the 4 layer internet model]]></title><description><![CDATA[<img alt="the 4 layer internet model-1677839765520.jpeg" src="https://rinodg.pages.dev/assets/image/the-4-layer-internet-model-1677839765520.jpeg" target="_self"><br><img alt="the 4 layer internet model-1677841182979.jpeg" src="https://rinodg.pages.dev/assets/image/the-4-layer-internet-model-1677841182979.jpeg" target="_self"><br><img alt="the 4 layer internet model-1677841972147.jpeg" src="https://rinodg.pages.dev/assets/image/the-4-layer-internet-model-1677841972147.jpeg" target="_self">
7-layer OSI Model has been replaced by four layer model.]]></description><link>https://rinodg.pages.dev/computer/computer-networking/the-4-layer-internet-model.html</link><guid isPermaLink="false">Computer/Computer Networking/the 4 layer internet model.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 11:12:56 GMT</pubDate><enclosure url="https://rinodg.pages.dev/assets/image/the-4-layer-internet-model-1677839765520.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://rinodg.pages.dev/assets/image/the-4-layer-internet-model-1677839765520.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[packet]]></title><description><![CDATA[network layer packets are called datagrams hey consist of some data and a header containing the to and from addresses]]></description><link>https://rinodg.pages.dev/computer/computer-networking/packet.html</link><guid isPermaLink="false">Computer/Computer Networking/packet.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 10:30:44 GMT</pubDate></item><item><title><![CDATA[CS144]]></title><link>https://rinodg.pages.dev/computer/computer-networking/cs144.html</link><guid isPermaLink="false">Computer/Computer Networking/CS144.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 10:26:51 GMT</pubDate></item><item><title><![CDATA[cs144 lab0]]></title><description><![CDATA[
In one terminal window, run netcat -v -l -p 9090 on your VM. You should see:
user@computer:~$ netcat -v -l -p 9090
Listening on [0.0.0.0] (family 0, port 9090) Leave netcat running. In another terminal window, run telnet localhost 9090 (also on your VM).
If all goes well, the netcat will have printed something like “Connection from localhost 53500 received!”.
When telnet is closed, netcat will also be closed.A receiver and a sender, which can be used to chat .In reality, however, the Internet doesn’t provide a service of reliable byte-streams. Instead, the only thing the Internet really does is to give its “best effort” to deliver short pieces of data, called Internet datagrams, to their destination. Each datagram contains some metadata (headers) that specifies things like the source and destination addresses—what computer it came from, and what computer it’s headed towards—as well as some payload data (up to about 1,500 bytes) to be delivered to the destination computer.
路由器中的 1492??Although the network tries to deliver every datagram, in practice datagrams can be (1) lost, (2) delivered out of order, (3) delivered with the contents altered, or even (4) duplicated and delivered more than once. It’s normally the job of the operating systems on either end of the connection to turn “best-effort datagrams” (the abstraction the Internet provides) into “<a data-href="reliable byte stream" href="https://rinodg.pages.dev/computer/computer-networking/reliable-byte-stream.html#_0" class="internal-link" target="_self" rel="noopener nofollow">reliable byte stream</a>s” (the abstraction that applications usually want)]]></description><link>https://rinodg.pages.dev/computer/computer-networking/cs144-lab0.html</link><guid isPermaLink="false">Computer/Computer Networking/cs144 lab0.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 09:01:39 GMT</pubDate></item><item><title><![CDATA[ARQ]]></title><description><![CDATA[自动重传请求（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ可能包括停止等待ARQ协议和连续ARQ协议，错误检测（Error Detection）、正面确认（Positive Acknowledgment）、超时重传（Retransmission after Timeout）和 负面确认及重传（Negative Acknowledgment and Retransmission）等机制。停止并等待协议的工作原理如下：
发送点对接收点发送数据包，然后等待接收点回复ACK并且开始计时。
在等待过程中，发送点停止发送新的数据包。
当数据包没有成功被接收点接收时候，接收点不会发送ACK。这样发送点在等待一定时间后，重新发送数据包。
反复以上步骤直到收到从接收点发送的ACK。
发送点的等待时间应当至少大于传输点数据包发送时间（数据包容量除以发送点传输速度），接收点ACK接收时间（ACK容量除以接收点传输速度），数据在连接上的传送时间，接收点检验接收数据是否正确的时间之和。在实际应用当中，等待时间是这个和的2到3倍。这个协议的缺点是较长的等待时间导致低的数据传输速度。在低速传输时，对连接频道的利用率比较好，但是在高速传输时，频道的利用率会显著下降。为了克服停止并等待ARQ协议长时间等待ACK的缺点。这个协议会连续发送一组数据包，然后再等待这些数据包的ACK。
接收点丢弃从第一个没有收到的数据包开始的所有数据包。
发送点收到NACK后，从NACK中指明的数据包开始重新发送。 发送点连续发送数据包但对每个数据包都设有个一个计时器。
当在一定时间内没有收到某个数据包的ACK时，发送点只重新发送那个没有ACK的数据包。
ARQ协议对错误纠正的方法是：
丢弃已经接收的含有错误的数据包。
向发送点请求重新发送数据包。
UMTS的ARQ机制是在<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E5%9F%BA%E5%9C%B0%E5%8F%B0%E6%8E%A7%E5%88%B6%E7%AB%99" rel="noopener nofollow" class="external-link is-unresolved" title="基地台控制站" href="https://zh.wikipedia.org/wiki/%E5%9F%BA%E5%9C%B0%E5%8F%B0%E6%8E%A7%E5%88%B6%E7%AB%99" target="_self">基地台控制站</a>（Radio Network Controller，<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/RNC" rel="noopener nofollow" class="external-link is-unresolved" title="RNC" href="https://zh.wikipedia.org/wiki/RNC" target="_self">RNC</a>），使用安置在协议数据单元（Protocol Data Unit，<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/PDU" rel="noopener nofollow" class="external-link is-unresolved" title="PDU" href="https://zh.wikipedia.org/wiki/PDU" target="_self">PDU</a>）前的序号来作为是否有封包丢失的依据，有不少的延迟时间。<br>ARQ协议的优点是它非常的简单。因而被广泛的应用在<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2" rel="noopener nofollow" class="external-link is-unresolved" title="分组交换" href="https://zh.wikipedia.org/wiki/%E5%88%86%E7%BB%84%E4%BA%A4%E6%8D%A2" target="_self">分组交换</a>网络中。ARQ协议的缺点是需要接收方发送ACK，这样增加了网络的负担也影响了传输速度。重复发送数据包来纠正错误的方法也严重的影响了它的传输速度。]]></description><link>https://rinodg.pages.dev/computer/computer-networking/arq.html</link><guid isPermaLink="false">Computer/Computer Networking/ARQ.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 08:53:25 GMT</pubDate></item><item><title><![CDATA[reliable byte stream]]></title><description><![CDATA[A reliable byte stream is a common service paradigm in computer networking; it refers to a byte stream in which the bytes which emerge from the communication channel at the recipient are exactly the same, and in exactly the same order, as they were when the sender inserted them into the channel.可靠字节流是一种常见的计算机网络服务示例；它代表一个字节流，其中从通信频道内传给接收者的每个字节，都与发送者传进频道内的每个字节相同，并且顺序也相同（亦即没有任何资料重置或损失）。可靠字节流网络传输协议的一个经典示例是传输控制协议（TCP），互联网的其中一个重要基石。然而，可靠字节流并不是唯一的可靠传输协议示例；其他协议（像是SCTP）提供的是可靠信息流，其定义是里面的资料会被分成独立的小单位，用类似独立对象的概念提供给用户。对实做可靠字节流的传输协议，一般会使用一些并不可靠的低端传输，然后使用一些机制来提升可靠性。在提升可靠性上，<a data-href="ARQ" href="https://rinodg.pages.dev/computer/computer-networking/arq.html#_0" class="internal-link" target="_self" rel="noopener nofollow">ARQ</a>协议扮演了一个非常重要的角色。所有的资料都以一个序号作认证，这是用来确保资料是以正确的顺序传给另一端的用户，以及用来检查失去的资料是哪些。接收者会在成功收到资料后回传一个确认通知（ACK）；如果没有在合理的回传时间内接收到确认通知，发送者的一个计时器会丢出超时信号，然后这个（我们认定已经失去的）资料会被重传。校验和（checksum）会在检查资料有否损毁时使用；在发送者传输任何资料区块时，会先计算好校验和，然后传给接收者用来确认。错误或者丧失的资料会回传给接收者，以让接收者稍候可以重传一份资料。任何多余的重复资料都会被丢弃。]]></description><link>https://rinodg.pages.dev/computer/computer-networking/reliable-byte-stream.html</link><guid isPermaLink="false">Computer/Computer Networking/reliable byte stream.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 08:51:18 GMT</pubDate></item><item><title><![CDATA[ETag]]></title><description><![CDATA[ETag或实体标签（entity tag）是万维网协议HTTP的一部分。ETag是HTTP协议提供的若干机制中的一种Web缓存验证机制，并且允许客户端进行缓存协商。这就使得缓存变得更加高效，而且节省带宽。如果资源的内容没有发生改变，Web服务器就不需要发送一个完整的响应。ETag也可用于乐观并发控制，作为一种防止资源同步更新而相互覆盖的方法。ETag是一个不透明的标识符，由Web服务器根据URL上的资源的特定版本而指定。如果那个URL上的资源内容改变，一个新的不一样的ETag就会被分配。用这种方法使用ETag即类似于指纹，并且他们能够被快速地被比较，以确定两个版本的资源是否相同。ETag的比较只对同一个URL有意义——不同URL上的资源的ETag值可能相同也可能不同，从他们的ETag的比较中无从推断。]]></description><link>https://rinodg.pages.dev/computer/computer-networking/etag.html</link><guid isPermaLink="false">Computer/Computer Networking/ETag.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 03 Mar 2023 08:33:44 GMT</pubDate></item><item><title><![CDATA[Computer Architecture (Machine Structures)]]></title><description><![CDATA[
Know the tools of the trade – computers! “Computers” come in all shapes and sizes
Computing achieved in many different ways nowadays Know when performance matters –Ex: taking advantage of parallelism Understand the differences between programming languages under the hood
Design large systems – abstraction in hardware
Security
Design methodology – limitations and tradeoffs Abstraction <img src="https://i.imgur.com/0fHF2mQ.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Technology Trends
<br>Principle of Locality/Memory Hierarchy <img src="https://i.imgur.com/6PPSZR7.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
<br>Parallelism <img src="https://i.imgur.com/0Iu6E6o.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Performance Measurement &amp; Improvement
<br>Dependability via Redundancy <img src="https://i.imgur.com/h2oYnQG.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
]]></description><link>https://rinodg.pages.dev/computer/computer-architecture/computer-architecture-(machine-structures).html</link><guid isPermaLink="false">Computer/Computer Architecture/Computer Architecture (Machine Structures).md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 02 Mar 2023 07:50:25 GMT</pubDate><enclosure url="https://i.imgur.com/0fHF2mQ.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/0fHF2mQ.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Rust Closures]]></title><description><![CDATA[Rust’s closures are anonymous functions you can save in a variable or pass as arguments to other functions. You can create the closure in one place and then call the closure elsewhere to evaluate it in a different context. Unlike functions, closures can capture values from the scope in which they’re defined. We’ll demonstrate how these closure features allow for code reuse and behavior customization.
Rust 的 闭包（closures）是可以保存在一个变量中或作为参数传递给其他函数的匿名函数。可以在一个地方创建闭包，然后在不同的上下文中执行闭包运算。不同于函数，闭包允许捕获被定义时所在作用域中的值。我们将展示闭包的这些功能如何复用代码和自定义行为。闭包可以通过三种方式捕获其环境，它们直接对应到函数获取参数的三种方式：不可变借用，可变借用和获取所有权。闭包会根据函数体中如何使用被捕获的值决定用哪种方式捕获。一旦闭包捕获了定义它的环境中一个值的引用或者所有权（也就影响了什么会被移 进 闭包，如有)，闭包体中的代码定义了稍后在闭包计算时对引用或值如何操作（也就影响了什么会被移 出 闭包，如有）。闭包体可以做以下任何事：将一个捕获的值移出闭包，修改捕获的值，既不移动也不修改值，或者一开始就不从环境中捕获值。闭包捕获和处理环境中的值的方式影响闭包实现的 trait。Trait 是函数和结构体指定它们能用的闭包的类型的方式。取决于闭包体如何处理值，闭包自动、渐进地实现一个、两个或三个 Fn trait。
FnOnce 适用于能被调用一次的闭包，所有闭包都至少实现了这个 trait，因为所有闭包都能被调用。一个会将捕获的值移出闭包体的闭包只实现 FnOnce trait，这是因为它只能被调用一次。
FnMut 适用于不会将捕获的值移出闭包体的闭包，但它可能会修改被捕获的值。这类闭包可以被调用多次。
Fn 适用于既不将被捕获的值移出闭包体也不修改被捕获的值的闭包，当然也包括不从环境中捕获值的闭包。这类闭包可以被调用多次而不改变它们的环境，这在会多次并发调用闭包的场景中十分重要。
]]></description><link>https://rinodg.pages.dev/computer/programming/rust/rust-closures.html</link><guid isPermaLink="false">Computer/Programming/Rust/Rust Closures.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 28 Feb 2023 14:22:56 GMT</pubDate></item><item><title><![CDATA[litetime]]></title><description><![CDATA[The main aim of lifetimes is to prevent dangling references, which cause a program to reference data other than the data it’s intended to reference. Consider the program in Listing 10-16, which has an outer scope and an inner scope.fn main() { let r; // ---------+-- 'a { // | let x = 5; // -+-- 'b | r = &amp;x; // | | } // -+ | println!("r: {}", r); // |
} // ---------+ the subject of the reference doesn’t live as long as the reference.生命周期注解语法生命周期注解并不改变任何引用的生命周期的长短。相反它们描述了多个引用生命周期相互的关系，而不影响其生命周期。与当函数签名中指定了泛型类型参数后就可以接受任何类型一样，当指定了泛型生命周期后函数也能接受任何生命周期的引用。&amp;i32 // 引用
&amp;'a i32 // 带有显式生命周期的引用
&amp;'a mut i32 // 带有显式生命周期的可变引用
One lifetime annotation by itself doesn’t have much meaning, because the annotations are meant to tell Rust how generic lifetime parameters of multiple references relate to each other.目前为止，我们定义的结构体全都包含拥有所有权的类型。也可以定义包含引用的结构体，不过这需要为结构体定义中的每一个引用添加生命周期注解。示例 10-24 中有一个存放了一个字符串 slice 的结构体 ImportantExcerpt。struct ImportantExcerpt&lt;'a&gt; { part: &amp;'a str,
} fn main() { let novel = String::from("Call me Ishmael. Some years ago..."); let first_sentence = novel.split('.').next().expect("Could not find a '.'"); let i = ImportantExcerpt { part: first_sentence, };
}
<a data-href="Lifetime Elision" href="https://rinodg.pages.dev/computer/programming/rust/lifetime-elision.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Lifetime Elision</a><br>
<a data-href="Lifetime Annotations in Method Definitions" href="https://rinodg.pages.dev/computer/programming/rust/lifetime-annotations-in-method-definitions.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Lifetime Annotations in Method Definitions</a><br>
<a data-href="Static Lifetime" href="https://rinodg.pages.dev/computer/programming/rust/static-lifetime.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Static Lifetime</a>]]></description><link>https://rinodg.pages.dev/computer/programming/rust/litetime.html</link><guid isPermaLink="false">Computer/Programming/Rust/litetime.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 28 Feb 2023 13:43:18 GMT</pubDate></item><item><title><![CDATA[Static Lifetime]]></title><description><![CDATA[One special lifetime we need to discuss is 'static, which denotes that the affected reference can live for the entire duration of the program. All string literals have the 'static lifetime, which we can annotate as follows:fn main() {
let s: &amp;'static str = "I have a static lifetime.";
}
The text of this string is stored directly in the program’s binary, which is always available. Therefore, the lifetime of all string literals is 'static.You might see suggestions to use the 'static lifetime in error messages. But before specifying 'static as the lifetime for a reference, think about whether the reference you have actually lives the entire lifetime of your program or not, and whether you want it to. Most of the time, an error message suggesting the 'static lifetime results from attempting to create a dangling reference or a mismatch of the available lifetimes. In such cases, the solution is fixing those problems, not specifying the 'static lifetime.]]></description><link>https://rinodg.pages.dev/computer/programming/rust/static-lifetime.html</link><guid isPermaLink="false">Computer/Programming/Rust/Static Lifetime.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 28 Feb 2023 13:43:14 GMT</pubDate></item><item><title><![CDATA[Lifetime Annotations in Method Definitions]]></title><description><![CDATA[（实现方法时）结构体字段的生命周期必须总是在 impl 关键字之后声明并在结构体名称之后被使用，因为这些生命周期是结构体类型的一部分。impl 块里的方法签名中，引用可能与结构体字段中的引用相关联，也可能是独立的。另外，生命周期省略规则也经常让我们无需在方法签名中使用生命周期注解。让我们看看一些使用示例 10-24 中定义的结构体 ImportantExcerpt 的例子。首先，这里有一个方法 level。其唯一的参数是 self 的引用，而且返回值只是一个 i32，并不引用任何值：
impl 之后和类型名称之后的生命周期参数是必要的，不过因为<a data-tooltip-position="top" aria-label="Lifetime Elision > ^7077e2" data-href="Lifetime Elision#^7077e2" href="https://rinodg.pages.dev/computer/programming/rust/lifetime-elision.html#^7077e2_0" class="internal-link" target="_self" rel="noopener nofollow">第一条生命周期规则</a>我们并不必须标注 self 引用的生命周期。struct ImportantExcerpt&lt;'a&gt; { part: &amp;'a str,
}
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; { fn level(&amp;self) -&gt; i32 { 3 }
}
<br>这里是一个适用于<a data-tooltip-position="top" aria-label="Lifetime Elision > ^c434f7" data-href="Lifetime Elision#^c434f7" href="https://rinodg.pages.dev/computer/programming/rust/lifetime-elision.html#^c434f7_0" class="internal-link" target="_self" rel="noopener nofollow">第三条生命周期省略规则</a>的例子：
impl&lt;'a&gt; ImportantExcerpt&lt;'a&gt; { fn announce_and_return_part(&amp;self, announcement: &amp;str) -&gt; &amp;str { println!("Attention please: {}", announcement); self.part }
} fn main() { let novel = String::from("Call me Ishmael. Some years ago..."); let first_sentence = novel.split('.').next().expect("Could not find a '.'"); let i = ImportantExcerpt { part: first_sentence, };
}
]]></description><link>https://rinodg.pages.dev/computer/programming/rust/lifetime-annotations-in-method-definitions.html</link><guid isPermaLink="false">Computer/Programming/Rust/Lifetime Annotations in Method Definitions.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 28 Feb 2023 13:40:52 GMT</pubDate></item><item><title><![CDATA[Lifetime Elision]]></title><description><![CDATA[被编码进 Rust 引用分析的模式被称为 生命周期省略规则（lifetime elision rules）。这并不是需要程序员遵守的规则；这些规则是一系列特定的场景，此时编译器会考虑，如果代码符合这些场景，就无需明确指定生命周期。函数或方法的参数的生命周期被称为 输入生命周期（input lifetimes），而返回值的生命周期被称为 输出生命周期（output lifetimes）。编译器采用三条规则来判断引用何时不需要明确的注解。第一条规则适用于输入生命周期，后两条规则适用于输出生命周期。如果编译器检查完这三条规则后仍然存在没有计算出生命周期的引用，编译器将会停止并生成错误。这些规则适用于 fn 定义，以及 impl 块。第一条规则是编译器为每一个是引用参数都分配了一个生命周期参数。换句话说就是，有一个引用参数的函数有一个生命周期参数：fn foo&lt;'a&gt;(x: &amp;'a i32)，有两个引用参数的函数有两个不同的生命周期参数，fn foo&lt;'a, 'b&gt;(x: &amp;'a i32, y: &amp;'b i32)，依此类推。 第二条规则是如果只有一个输入生命周期参数，那么它被赋予所有输出生命周期参数：fn foo&lt;'a&gt;(x: &amp;'a i32) -&gt; &amp;'a i32。第三条规则是如果方法有多个输入生命周期参数并且其中一个参数是 &amp;self 或 &amp;mut self，说明是个对象的方法 (method)(译者注：这里涉及 rust 的面向对象参见 17 章)，那么所有输出生命周期参数被赋予 self 的生命周期。第三条规则使得方法更容易读写，因为只需更少的符号。 ]]></description><link>https://rinodg.pages.dev/computer/programming/rust/lifetime-elision.html</link><guid isPermaLink="false">Computer/Programming/Rust/Lifetime Elision.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 28 Feb 2023 13:40:50 GMT</pubDate></item><item><title><![CDATA[thread pool]]></title><description><![CDATA[A thread pool is a group of spawned threads that are waiting and ready to handle a task.When the program receives a new task, it assigns one of the threads in the pool to the task, and that thread will process the task.]]></description><link>https://rinodg.pages.dev/computer/thread-pool.html</link><guid isPermaLink="false">Computer/thread pool.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 28 Feb 2023 07:16:20 GMT</pubDate></item><item><title><![CDATA[Function-like macros]]></title><description><![CDATA[Function-like macros define macros that look like function calls. Similarly to macro_rules! macros, they’re more flexible than functions; for example, they can take an unknown number of arguments. However, macro_rules! macros can be defined only using the match-like syntax we discussed in the section <a data-tooltip-position="top" aria-label="chrome-extension://pcmpcfapbekmbjjkdalcgopdkipoggdi/_generated_background_page.html#declarative-macros-with-macro_rules-for-general-metaprogramming" rel="noopener nofollow" class="external-link is-unresolved" href="https://rinodg.pages.dev/chrome-extension:/pcmpcfapbekmbjjkdalcgopdkipoggdi/_generated_background_page.html#declarative-macros-with-macro_rules-for-general-metaprogramming" target="_self">“Declarative Macros with <code></code> for General Metaprogramming”</a>macro_rules! earlier. Function-like macros take a TokenStream parameter and their definition manipulates that TokenStream using Rust code as the other two types of procedural macros do. An example of a function-like macro is an sql! macro that might be called like so:let sql = sql!(SELECT * FROM posts WHERE id=1);
This macro would parse the SQL statement inside it and check that it’s syntactically correct, which is much more complex processing than a macro_rules! macro can do. The sql! macro would be defined like this:#[proc_macro]
pub fn sql(input: TokenStream) -&gt; TokenStream {
This definition is similar to the custom derive macro’s signature: we receive the tokens that are inside the parentheses and return the code we wanted to generate.]]></description><link>https://rinodg.pages.dev/computer/programming/rust/function-like-macros.html</link><guid isPermaLink="false">Computer/Programming/Rust/Function-like macros.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 27 Feb 2023 09:25:39 GMT</pubDate></item><item><title><![CDATA[Attribute-like macros]]></title><description><![CDATA[Attribute-like macros are similar to custom derive macros, but instead of generating code for the derive attribute, they allow you to create new attributes. They’re also more flexible: derive only works for structs and enums; attributes can be applied to other items as well, such as functions. Here’s an example of using an attribute-like macro: say you have an attribute named route that annotates functions when using a web application framework:#[route(GET, "/")]
fn index() {
This #[route] attribute would be defined by the framework as a procedural macro. The signature of the macro definition function would look like this:#[proc_macro_attribute]
pub fn route(attr: TokenStream, item: TokenStream) -&gt; TokenStream {
Here, we have two parameters of type TokenStream. The first is for the contents of the attribute: the GET, "/" part. The second is the body of the item the attribute is attached to: in this case, fn index() {} and the rest of the function’s body.Other than that, attribute-like macros work the same way as custom derive macros: you create a crate with the proc-macro crate type and implement a function that generates the code you want!]]></description><link>https://rinodg.pages.dev/computer/programming/rust/attribute-like-macros.html</link><guid isPermaLink="false">Computer/Programming/Rust/Attribute-like macros.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 27 Feb 2023 09:25:25 GMT</pubDate></item><item><title><![CDATA[derive Macro]]></title><description><![CDATA[Let’s create a crate named hello_macro that defines a trait named HelloMacro with one associated function named hello_macro. Rather than making our users implement the HelloMacro trait for each of their types, we’ll provide a procedural macro so users can annotate their type with #[derive(HelloMacro)] to get a default implementation of the hello_macro function. The default implementation will print Hello, Macro! My name is TypeName! where TypeName is the name of the type on which this trait has been defined. In other words, we’ll write a crate that enables another programmer to write code like Listing 19-30 using our crate.use hello_macro::HelloMacro;
use hello_macro_derive::HelloMacro; #[derive(HelloMacro)]
struct Pancakes; fn main() { Pancakes::hello_macro();
}
equivalent touse hello_macro::HelloMacro; struct Pancakes; impl HelloMacro for Pancakes { fn hello_macro() { println!("Hello, Macro! My name is Pancakes!"); }
} fn main() { Pancakes::hello_macro();
}
derive 是 Rust 中的一个宏，它允许程序员根据一个或多个 trait 自动为结构体或枚举类型实现方法。这个宏是 Rust 语言中非常常用的一个特性，能够减少编写重复代码的工作量，并提高代码的可维护性。derive 宏用于自动生成一些常见的实现，比如比较运算符、打印调试信息、序列化和反序列化等。例如，为了让一个结构体可以通过 println! 宏输出，只需要在结构体的定义前面加上 #[derive(Debug)]，就可以自动生成 Debug trait 的实现。下面是一个例子：rustCopy code#[derive(Debug)]
struct Person { name: String, age: u32,
} fn main() { let p = Person { name: String::from("Alice"), age: 30 }; println!("{:?}", p);
} 在上面的例子中，Person 结构体通过 derive(Debug) 自动生成了 Debug trait 的实现。在 main 函数中，我们可以使用 println! 宏输出 Person 实例的调试信息。derive 宏不仅可以应用于结构体类型，也可以应用于枚举类型，用于自动生成枚举类型的一些常见实现。例如，为了让一个枚举类型可以通过 match 表达式进行匹配，只需要在枚举类型的定义前面加上 #[derive(Debug, PartialEq)]，就可以自动生成 Debug 和 PartialEq trait 的实现。总之，derive 宏是 Rust 语言中的一个非常实用的特性，可以帮助程序员自动生成一些常见的实现，从而减少重复劳动，提高代码的可维护性和可读性。]]></description><link>https://rinodg.pages.dev/computer/programming/rust/derive-macro.html</link><guid isPermaLink="false">Computer/Programming/Rust/derive Macro.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 27 Feb 2023 09:22:02 GMT</pubDate></item><item><title><![CDATA[declarative macro]]></title><description><![CDATA[#[macro_export]
macro_rules! vec { ( $( $x:expr ),* ) =&gt; { { let mut temp_vec = Vec::new(); $( temp_vec.push($x); )* temp_vec } };
}
The #[macro_export] annotation indicates that this macro should be made available whenever the crate in which the macro is defined is brought into scope. Without this annotation, the macro can’t be brought into scope.We then start the macro definition with macro_rules! and the name of the macro we’re defining without the exclamation mark. The name, in this case vec, is followed by curly brackets denoting the body of the macro definition.The structure in the vec! body is similar to the structure of a match expression. Here we have one arm with the pattern ( $( $x:expr ),* ), followed by =&gt; and the block of code associated with this pattern. If the pattern matches, the associated block of code will be emitted. Given that this is the only pattern in this macro, there is only one valid way to match; any other pattern will result in an error. More complex macros will have more than one arm.
First, we use a set of parentheses to encompass the whole pattern. We use a dollar sign ($) to declare a variable in the macro system that will contain the Rust code matching the pattern. The dollar sign makes it clear this is a macro variable as opposed to a regular Rust variable. Next comes a set of parentheses that captures values that match the pattern within the parentheses for use in the replacement code. Within $() is $x:expr, which matches any Rust expression and gives the expression the name $x.Dataview (inline field '&gt;'): Error: -- PARSING FAILED -------------------------------------------------- &gt; 1 | &gt; | ^ Expected one of the following: '(', 'null', boolean, date, duration, file link, list ('[1, 2, 3]'), negated field, number, object ('{ a: 1, b: 2 }'), string, variable
The comma following $() indicates that a literal comma separator character could optionally appear after the code that matches the code in $(). The * specifies that the pattern matches zero or more of whatever precedes the *.When we call this macro with vec![1, 2, 3];, the $x pattern matches three times with the three expressions 1, 2, and 3.Now let’s look at the pattern in the body of the code associated with this arm: temp_vec.push() within $()* is generated for each part that matches $() in the pattern zero or more times depending on how many times the pattern matches. The $x is replaced with each expression matched. When we call this macro with vec![1, 2, 3];, the code generated that replaces this macro call will be the following:{ let mut temp_vec = Vec::new(); temp_vec.push(1); temp_vec.push(2); temp_vec.push(3); temp_vec
}
We’ve defined a macro that can take any number of arguments of any type and can generate code to create a vector containing the specified elements.To learn more about how to write macros, consult the online documentation or other resources, such as <a data-tooltip-position="top" aria-label="https://veykril.github.io/tlborm/" rel="noopener nofollow" class="external-link is-unresolved" href="https://veykril.github.io/tlborm/" target="_self">“The Little Book of Rust Macros”</a> started by Daniel Keep and continued by Lukas Wirth.]]></description><link>https://rinodg.pages.dev/computer/programming/rust/declarative-macro.html</link><guid isPermaLink="false">Computer/Programming/Rust/declarative macro.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 27 Feb 2023 09:14:04 GMT</pubDate></item><item><title><![CDATA[unsafe rust]]></title><description><![CDATA[To switch to unsafe Rust, use the unsafe keyword and then start a new block that holds the unsafe code. You can take five actions in unsafe Rust that you can’t in safe Rust, which we call unsafe superpowers. Those superpowers include the ability to:
Dereference a raw pointer
Call an unsafe function or method
Access or modify a mutable static variable
Implement an unsafe trait
Access fields of unions
The unsafe keyword only gives you access to these five features that are then not checked by the compiler for memory safety. You’ll still get some degree of safety inside of an unsafe block.]]></description><link>https://rinodg.pages.dev/computer/programming/rust/unsafe-rust.html</link><guid isPermaLink="false">Computer/Programming/Rust/unsafe rust.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 27 Feb 2023 07:44:42 GMT</pubDate></item><item><title><![CDATA[Rust]]></title><link>https://rinodg.pages.dev/computer/programming/rust/rust.html</link><guid isPermaLink="false">Computer/Programming/Rust/Rust.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 27 Feb 2023 07:42:02 GMT</pubDate></item><item><title><![CDATA[Rust Pattern Matching]]></title><description><![CDATA[Patterns come in two forms: refutable and irrefutable.
Patterns that will match for any possible value passed are irrefutable. An example would be x in the statement let x = 5; because x matches anything and therefore cannot fail to match. Patterns that can fail to match for some possible value are refutable. An example would be Some(x) in the expression if let Some(x) = a_value because if the value in the a_value variable is None rather than Some, the Some(x) pattern will not match.Cases:In match expressions, you can match multiple patterns using the | syntax, which is the pattern or operator. For example, in the following code we match the value of x against the match arms, the first of which has an or option, meaning if the value of x matches either of the values in that arm, that arm’s code will run:fn main() { let x = 1; match x { 1 | 2 =&gt; println!("one or two"), 3 =&gt; println!("three"), _ =&gt; println!("anything"), }
}
This code prints one or two.The ..= syntax allows us to match to an inclusive range of values. In the following code, when a pattern matches any of the values within the given range, that arm will execute:fn main() { let x = 5; match x { 1..=5 =&gt; println!("one through five"), _ =&gt; println!("something else"), }
}
If x is 1, 2, 3, 4, or 5, the first arm will match. This syntax is more convenient for multiple match values than using the | operator to express the same idea; if we were to use | we would have to specify 1 | 2 | 3 | 4 | 5. Specifying a range is much shorter, especially if we want to match, say, any number between 1 and 1,000!The compiler checks that the range isn’t empty at compile time, and because the only types for which Rust can tell if a range is empty or not are char and numeric values, ranges are only allowed with numeric or char values.Here is an example using ranges of char values:fn main() { let x = 'c'; match x { 'a'..='j' =&gt; println!("early ASCII letter"), 'k'..='z' =&gt; println!("late ASCII letter"), _ =&gt; println!("something else"), }
}
Rust can tell that 'c' is within the first pattern’s range and prints early ASCII letter.fn main() { let favorite_color: Option&lt;&amp;str&gt; = None; let is_tuesday = false; let age: Result&lt;u8, _&gt; = "34".parse(); if let Some(color) = favorite_color { println!("Using your favorite color, {color}, as the background"); } else if is_tuesday { println!("Tuesday is green day!"); } else if let Ok(age) = age { if age &gt; 30 { println!("Using purple as the background color"); } else { println!("Using orange as the background color"); } } else { println!("Using blue as the background color"); }
}
]]></description><link>https://rinodg.pages.dev/computer/programming/rust/rust-pattern-matching.html</link><guid isPermaLink="false">Computer/Programming/Rust/Rust Pattern Matching.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 27 Feb 2023 07:36:48 GMT</pubDate></item><item><title><![CDATA[Rust OOP]]></title><description><![CDATA[在 rust 中 trait 代表一个行为，它不包含 Object。
their specific purpose is to allow abstraction across common behavior.You answered 0/1 questions correctly.In the running example from this section, a blog post could have one of three states: Draft, PendingReview, and Published. In the example, each state was represented as a struct, and state transitions was represented as trait methods returning trait objects.An alternative implementation could represent the states as an enum, like this:enum BlogState { Draft, PendingReview, Published
} impl Post { fn request_review(&amp;mut self) { use BlogState::*; self.state = match self.state { Draft =&gt; PendingReview, PendingReview =&gt; PendingReview, Published =&gt; Published } }
}
Which of the following are valid reasons to prefer the struct/trait representation over the enum representation?🐞You answered:
An API client could add a new method for all states in the system
The use of match is slower at runtime than dynamic dispatch
The correct answer is:
An API client could add a new state to the system
Adding a new state does not require modifying methods on other states
Context: The struct/trait approach is extensible in the sense that an API client could potentially create a new state (such as Retracted) without changing the core API functionality. When adding this state, the methods for other states do not need to be changed. Whereas with enums, a client cannot add a new branch to the enum. Moreover, all match expressions must be updated when a state is added.A match is not likely to be slower than dynamic dispatch. A match is a simple branch based on an enum's tag, while dynamic dispatch requires layers of indirection through a trait object's virtual table with non-inlined function calls.An API client cannot add a new method for existing states in the struct/trait approach, they can only add new states. The methods are fixed by the API author's trait definition. Note that you could add a new method which only builds on existing methods via extension traits, such as:trait StateExt { fn request_review_twice(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt;;
} impl&lt;S: State&gt; StateExt for S { fn request_review_twice(self: Box&lt;Self&gt;) -&gt; Box&lt;dyn State&gt; { self.request_review().request_review() }
}
But these extensions cannot read the internal data of the states.]]></description><link>https://rinodg.pages.dev/computer/programming/rust/rust-oop.html</link><guid isPermaLink="false">Computer/Programming/Rust/Rust OOP.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sun, 26 Feb 2023 08:57:14 GMT</pubDate></item><item><title><![CDATA[When to use DP]]></title><description><![CDATA[
The problem can be broken down into "overlapping subproblems" - smaller versions of the original problem that are re-used multiple times
The problem has an "optimal substructure" - an optimal solution can be formed from optimal solutions to the overlapping subproblems of the original problem
The first characteristic that is common in DP problems is that the problem will ask for the optimum value (maximum or minimum) of something, or the number of ways there are to do something. For example:
What is the minimum cost of doing...
What is the maximum profit from...
How many ways are there to do...
What is the longest possible...
Is it possible to reach a certain point...
The second characteristic that is common in DP problems is that future "decisions" depend on earlier decisions. Deciding to do something at one step may affect the ability to do something in a later step. This characteristic is what makes a greedy algorithm invalid for a DP problem - we need to factor in results from previous decisions. Admittedly, this characteristic is not as well defined as the first one, and the best way to identify it is to go through some examples.]]></description><link>https://rinodg.pages.dev/computer/data-structure/when-to-use-dp.html</link><guid isPermaLink="false">Computer/Data Structure/When to use DP.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sun, 26 Feb 2023 03:05:09 GMT</pubDate></item><item><title><![CDATA[dynamic programming]]></title><description><![CDATA[There are two ways to implement a DP algorithm:
Bottom-up, also known as tabulation.
Top-down, also known as memoization.
<a data-href="When to use DP" href="https://rinodg.pages.dev/computer/data-structure/when-to-use-dp.html#_0" class="internal-link" target="_self" rel="noopener nofollow">When to use DP</a>Bottom-up is implemented with iteration and starts at the base cases. Let's use the Fibonacci sequence as an example again. The base cases for the Fibonacci sequence are and . With bottom-up, we would use these base cases to calculate , and then use that result to calculate , and so on all the way up to .// Pseudocode example for bottom-up F = array of length (n + 1)
F[0] = 0
F[1] = 1
for i from 2 to n: F[i] = F[i - 1] + F[i - 2] Top-down is implemented with recursion and made efficient with memoization. If we wanted to find the Fibonacci number , we try to compute this by finding and . This defines a recursive pattern that will continue on until we reach the base cases . The problem with just implementing it recursively is that there is a ton of unnecessary repeated computation. Take a look at the recursion tree if we were to find :<br><img src="https://leetcode.com/explore/featured/card/dynamic-programming/630/an-introduction-to-dynamic-programming/4035//../../../../Figures/DP1/C1A2_1.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Notice that we need to calculate F(2) three times. This might not seem like a big deal, but if we were to calculate F(6), this entire image would be only one child of the root. Imagine if we wanted to find F(100) - the amount of computation is exponential and will quickly explode. The solution to this is to memoize results.
memoizing a result means to store the result of a function call, usually in a hashmap or an array, so that when the same function call is made again, we can simply return the memoized result instead of recalculating the result.
After we calculate F(2), let's store it somewhere (typically in a hashmap), so in the future, whenever we need to find F(2), we can just refer to the value we already calculated instead of having to go through the entire tree again. Below is an example of what the recursion tree for finding F(6) looks like with and without memoization:// Pseudocode example for top-down memo = hashmap
Function F(integer i): if i is 0 or 1: return i if i doesn't exist in memo: memo[i] = F(i - 1) + F(i - 2) return memo[i]
Any DP algorithm can be implemented with either method, and there are reasons for choosing either over the other. However, each method has one main advantage that stands out:
A bottom-up implementation's runtime is usually faster, as iteration does not have the overhead that recursion does.
A top-down implementation is usually much easier to write. This is because with recursion, the ordering of subproblems does not matter, whereas with tabulation, we need to go through a logical ordering of solving subproblems. We'll be talking more about these two options throughout the card. For now, all you need to know is that top-down uses recursion, and bottom-up uses iteration.
]]></description><link>https://rinodg.pages.dev/computer/data-structure/dynamic-programming.html</link><guid isPermaLink="false">Computer/Data Structure/dynamic programming.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sun, 26 Feb 2023 02:59:47 GMT</pubDate><enclosure url="https://leetcode.com/explore/featured/card/dynamic-programming/630/an-introduction-to-dynamic-programming/4035//../../../../Figures/DP1/C1A2_1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://leetcode.com/explore/featured/card/dynamic-programming/630/an-introduction-to-dynamic-programming/4035//../../../../Figures/DP1/C1A2_1.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Dijkstra]]></title><description><![CDATA[用于解决有权图最短路径
可以用于货币转换
Dijkstra's algorithm is not guaranteed to be correct for negative edges. It might work... but it isn't guaranteed to work.
Dijkstra 的算法不保证对负 Edge 是正确的。它可能有效……但不能保证有效。Observe that once a vertex is popped off the <a data-href="Priority Queue" href="https://rinodg.pages.dev/computer/data-structure/priority-queue.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Priority Queue</a>, it is never re-added. Its distance is never re-updated. So, in other words, once a vertex is popped from the <a data-href="Priority Queue" href="https://rinodg.pages.dev/computer/data-structure/priority-queue.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Priority Queue</a>, we&nbsp;know&nbsp;the true shortest distance to that vertex from the source.Dijkstra is however generally considered better in the absence of negative weight edges, as a typical binary heap priority queue implementation has time complexity A Fibonacci heap priority queue gives , while the Bellman-Ford algorithm has complexityDemo:<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.google.com/presentation/d/1_bw2z1ggUkquPdhl7gwdVBoTaoJmaZdpkV6MoAgxlJc/pub?start=false&amp;loop=false&amp;delayms=3000" target="_self">https://docs.google.com/presentation/d/1_bw2z1ggUkquPdhl7gwdVBoTaoJmaZdpkV6MoAgxlJc/pub?start=false&amp;loop=false&amp;delayms=3000</a><br><a data-href="Bellman-Ford" href="https://rinodg.pages.dev/computer/data-structure/bellman-ford.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Bellman-Ford</a><br>
<a data-href="A star" href="https://rinodg.pages.dev/computer/data-structure/a-star.html#_0" class="internal-link" target="_self" rel="noopener nofollow">A star</a>]]></description><link>https://rinodg.pages.dev/computer/data-structure/dijkstra.html</link><guid isPermaLink="false">Computer/Data Structure/Dijkstra.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 26 Jan 2023 03:17:26 GMT</pubDate></item><item><title><![CDATA[Depth First TraversaIs]]></title><description><![CDATA[Preorder traversal: "Visit" a node, then traverse its children: DBACFEG
often use to print directory list
<img src="https://i.imgur.com/SMVJ7dq.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
lnorder traversal: Traverse left child, visit, then traverse right child: ABCDEFGPostorder traversal; Traverseleft, traverse right, then visit: ACBEGFD
Postorder Traversal for gathering file sizes.postOrder(BSTNode x) { if (x == null) return 0; int total = 0; for (BSTNode c : x.children()) total += postOrder(c) total += x.fileSize(); return total;
} <br><img src="https://i.imgur.com/TY4c4Av.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>https://rinodg.pages.dev/computer/data-structure/depth-first-traversais.html</link><guid isPermaLink="false">Computer/Data Structure/Depth First TraversaIs.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 09 Jan 2023 01:56:56 GMT</pubDate><enclosure url="https://i.imgur.com/SMVJ7dq.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/SMVJ7dq.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Tries]]></title><description><![CDATA[Short for Retrieval Tree
Inventor Edward Fredkin suggested it should be pronounced "tree", but
almost everyone pronounces it like "try".For String keys, we can use a “Trie”. Key ideas:
Every node stores only one letter.
Nodes can be shared by multiple keys.
<img src="https://i.imgur.com/LtFJ0Bo.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">应用在 autocomplete]]></description><link>https://rinodg.pages.dev/computer/data-structure/tries.html</link><guid isPermaLink="false">Computer/Data Structure/Tries.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 31 Dec 2022 10:38:58 GMT</pubDate><enclosure url="https://i.imgur.com/LtFJ0Bo.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/LtFJ0Bo.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[server side session]]></title><description><![CDATA[The negative aspect of server side sessions is the increased complexity in the backend and also the effect on performance since the token validity needs to be checked for each API request from database. A database access is considerably slower compared to checking the validity from the token itself. That is why it is a quite common to save the session corresponding to a token to a key-value-database such as Redis that is limited in functionality compared to eg. <a data-href="MongoDB" href="https://rinodg.pages.dev/computer/web-applications/mongodb.html#_0" class="internal-link" target="_self" rel="noopener nofollow">MongoDB</a> or relational database but extremely fast in some usage scenarios.]]></description><link>https://rinodg.pages.dev/computer/web-applications/server-side-session.html</link><guid isPermaLink="false">Computer/Web Applications/server side session.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 21 Dec 2022 12:42:43 GMT</pubDate></item><item><title><![CDATA[Token authentication]]></title><description><![CDATA[<img src="https://fullstackopen.com/static/8b2839fe97680c325df6647121af66c3/5a190/16e.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
This causes the React code to send the username and the password to the server address /api/login as a HTTP POST request.
If the username and the password are correct, the server generates a token which somehow identifies the logged in user. The token is signed digitally, making it impossible to falsify (with cryptographic means) The backend responds with a status code indicating the operation was successful, and returns the token with the response.
The browser saves the token, for example to the state of a React application.
When the user creates a new note (or does some other operation requiring identification), the React code sends the token to the server with the request.
The server uses the token to identify the user
<br>The other solution is to save info about each token to backend database and to check for each API request if the access right corresponding to the token is still valid. With this scheme, the access rights can be revoked at any time. This kind of solution is often called a <a data-href="server side session" href="https://rinodg.pages.dev/computer/web-applications/server-side-session.html#_0" class="internal-link" target="_self" rel="noopener nofollow">server side session</a>.]]></description><link>https://rinodg.pages.dev/computer/web-applications/token-authentication.html</link><guid isPermaLink="false">Computer/Web Applications/Token authentication.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 15 Dec 2022 16:22:01 GMT</pubDate><enclosure url="https://fullstackopen.com/static/8b2839fe97680c325df6647121af66c3/5a190/16e.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://fullstackopen.com/static/8b2839fe97680c325df6647121af66c3/5a190/16e.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Web Applications]]></title><description><![CDATA[<img src="https://i.imgur.com/25XSdu5.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Technologies used to build modern web applications Note: CS14x (computer system course in Computer Science department)
FuII stack: Browser ⇔ Web server ⇔ Storage system
Learning Goal: Learn how a web application is built and run How to build a web application - learn by doing. Use MERN stack (React.js, Node.js, Express.js, MongoDB)
Learning Goal: Build a photo sharing we b app and understand h OW it works ！ CS142 Technologies and Concepts
Browser environment:
<br><a data-tooltip-position="top" aria-label="HyperText Markup Language" data-href="HyperText Markup Language" href="https://rinodg.pages.dev/computer/web-applications/hypertext-markup-language.html#_0" class="internal-link" target="_self" rel="noopener nofollow">HTML</a>/<a data-tooltip-position="top" aria-label="Cascading Style Sheets" data-href="Cascading Style Sheets" href="https://rinodg.pages.dev/computer/web-applications/cascading-style-sheets.html#_0" class="internal-link" target="_self" rel="noopener nofollow">CSS</a>/<a data-href="JavaScript" href="https://rinodg.pages.dev/computer/web-applications/javascript.html#_0" class="internal-link" target="_self" rel="noopener nofollow">JavaScript</a> - Markup, separation of content &amp; style, reuse, scripting
<br><a data-href="Document object Model" href="https://rinodg.pages.dev/computer/web-applications/document-object-model.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Document object Model</a> (DOM) - Document structure
<br><a data-tooltip-position="top" aria-label="Universal Resource Locator" data-href="Universal Resource Locator" href="https://rinodg.pages.dev/computer/web-applications/universal-resource-locator.html#_0" class="internal-link" target="_self" rel="noopener nofollow">URL</a>
Browser software:
<br>Model View Controller, <a data-href="Single page applications" href="https://rinodg.pages.dev/computer/web-applications/single-page-applications.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Single page applications</a>, Responsive design - <a data-href="React.js" href="https://rinodg.pages.dev/computer/web-applications/react.js.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React.js</a>
Backend communication:
<br>API design - HTTP/AJAX/<a data-href="REST" href="https://rinodg.pages.dev/computer/web-applications/rest.html#_0" class="internal-link" target="_self" rel="noopener nofollow">REST</a>/<a data-href="GraphQL" href="https://rinodg.pages.dev/computer/web-applications/graphql.html#_0" class="internal-link" target="_self" rel="noopener nofollow">GraphQL</a>
<br>Cookies/Sessions/State management - Storage/Trust <a data-href="Token authentication" href="https://rinodg.pages.dev/computer/web-applications/token-authentication.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Token authentication</a>
Backend implementation:
<br>Web Server - HTTP request processing - <a data-href="Node.js" href="https://rinodg.pages.dev/computer/web-applications/node.js.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Node.js</a>
<br>DBMS - Schema, Objects, CRUD, indexes, transactions - <a data-href="MongoDB" href="https://rinodg.pages.dev/computer/web-applications/mongodb.html#_0" class="internal-link" target="_self" rel="noopener nofollow">MongoDB</a>
End-to-End - Scale and Security
Web 开发的第一原则。始终打开你的网络浏览器上的开发者控制台。在macOS上，通过F12或同时按下option-cmd-i来打开控制台。 在Windows或Linux上，通过F12或同时按ctrl-shift-i来打开控制台。控制台也可以通过上下文菜单打开。<br><a data-href="HTTP GET" href="https://rinodg.pages.dev/computer/web-applications/http-get.html#_0" class="internal-link" target="_self" rel="noopener nofollow">HTTP GET</a>]]></description><link>https://rinodg.pages.dev/computer/web-applications/web-applications.html</link><guid isPermaLink="false">Computer/Web Applications/Web Applications.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 14 Dec 2022 15:28:17 GMT</pubDate><enclosure url="https://i.imgur.com/25XSdu5.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/25XSdu5.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Promise]]></title><description><![CDATA[(<a rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_self">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise</a>)Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。一个 Promise 对象代表一个在这个 promise 被创建出来时不一定已知值的代理。它让你能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。这样使得异步方法可以像同步方法那样返回值：异步方法并不会立即返回最终的值，而是会返回一个 promise，以便在未来某个时候把值交给使用者。一个 Promise 必然处于以下几种状态之一：
待定（pending）：初始状态，既没有被兑现，也没有被拒绝。
已兑现（fulfilled）：意味着操作成功完成。
已拒绝（rejected）：意味着操作失败。
待定状态的 Promise 对象要么会通过一个值被兑现，要么会通过一个原因（错误）被拒绝。当这些情况之一发生时，我们用 promise 的 then 方法排列起来的相关处理程序就会被调用。如果 promise 在一个相应的处理程序被绑定时就已经被兑现或被拒绝了，那么这个处理程序也同样会被调用，因此在完成异步操作和绑定处理方法之间不存在竞态条件。因为 Promise.prototype.then 和 Promise.prototype.catch 方法返回的是 promise，所以它们可以被链式调用。
备注： 有一些语言中有惰性求值和延迟计算的特性，它们也被称为“promise”，例如 Scheme。JavaScript 中的 promise 代表的是已经在发生的进程，而且可以通过回调函数实现链式调用。如果你想对一个表达式进行惰性求值，就考虑一下使用无参数的箭头函数，如 f = () =&gt; expression 来创建惰性求值的表达式，然后使用 f() 进行求值。
<br>
备注： 如果一个 promise 已经被兑现或被拒绝，那么我们也可以说它处于 已敲定（settled） 状态。你还会听到一个经常跟 promise 一起使用的术语：已决议（resolved），它表示 promise 已经处于已敲定状态，或者为了匹配另一个 promise 的状态被“锁定”了。Domenic Denicola 的 <a data-tooltip-position="top" aria-label="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md" target="_self">States and fates</a> 中有更多关于 promise 术语的细节可以供你参考。
]]></description><link>https://rinodg.pages.dev/computer/web-applications/promise.html</link><guid isPermaLink="false">Computer/Web Applications/Promise.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 12 Dec 2022 05:40:53 GMT</pubDate></item><item><title><![CDATA[JavaScript]]></title><description><![CDATA[另一方面，JavaScript引擎或运行时环境遵循异步模型。原则上，这要求所有的IO-操作（除了一些例外)都以非阻塞方式执行。这意味着在调用一个IO函数后，代码的执行会立即继续，而不需要等待它的返回。 <a data-tooltip-position="top" aria-label="javascript-async" data-href="javascript-async" href="https://rinodg.pages.dev/computer/web-applications/javascript-async.html#_0" class="internal-link" target="_self" rel="noopener nofollow">async/await</a>]]></description><link>https://rinodg.pages.dev/computer/web-applications/javascript.html</link><guid isPermaLink="false">Computer/Web Applications/JavaScript.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 12 Dec 2022 05:36:41 GMT</pubDate></item><item><title><![CDATA[MongoDB]]></title><description><![CDATA[const mongoose = require('mongoose') if (process.argv.length &lt; 3) { console.log('Please provide the password as an argument: node mongo.js &lt;password&gt;') process.exit(1)
} const password = process.argv[2] const url = `mongodb+srv://fullstack:${password}@cluster0.o1opl.mongodb.net/myFirstDatabase?retryWrites=true&amp;w=majority` mongoose.connect(url) const noteSchema = new mongoose.Schema({ content: String, date: Date, important: Boolean,
}) const Note = mongoose.model('Note', noteSchema) const note = new Note({ content: 'HTML is Easy', date: new Date(), important: true,
}) note.save().then(result =&gt; { console.log('note saved!') mongoose.connection.close()
})
After establishing the connection to the database, we define the <a data-tooltip-position="top" aria-label="http://mongoosejs.com/docs/guide.html" rel="noopener nofollow" class="external-link is-unresolved" href="http://mongoosejs.com/docs/guide.html" target="_self">schema</a> for a note and the matching <a data-tooltip-position="top" aria-label="http://mongoosejs.com/docs/models.html" rel="noopener nofollow" class="external-link is-unresolved" href="http://mongoosejs.com/docs/models.html" target="_self">model</a>:const noteSchema = new mongoose.Schema({ content: String, date: Date, important: Boolean,
}) const Note = mongoose.model('Note', noteSchema)
<br>First we define the <a data-tooltip-position="top" aria-label="http://mongoosejs.com/docs/guide.html" rel="noopener nofollow" class="external-link is-unresolved" href="http://mongoosejs.com/docs/guide.html" target="_self">schema</a> of a note that is stored in the noteSchema variable. The schema tells Mongoose how the note objects are to be stored in the database.<br>In the Note model definition, the first "Note" parameter is the singular name of the model. The name of the collection will be the lowercased plural notes, because the <a data-tooltip-position="top" aria-label="http://mongoosejs.com/docs/models.html" rel="noopener nofollow" class="external-link is-unresolved" href="http://mongoosejs.com/docs/models.html" target="_self">Mongoose convention</a> is to automatically name collections as the plural (e.g. notes) when the schema refers to them in the singular (e.g. Note).Document databases like Mongo are schemaless, meaning that the database itself does not care about the structure of the data that is stored in the database. It is possible to store documents with completely different fields in the same collection.The idea behind Mongoose is that the data stored in the database is given a schema at the level of the application that defines the shape of the documents stored in any given collection.]]></description><link>https://rinodg.pages.dev/computer/web-applications/mongodb.html</link><guid isPermaLink="false">Computer/Web Applications/MongoDB.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sun, 11 Dec 2022 02:21:51 GMT</pubDate></item><item><title><![CDATA[Node.js]]></title><description><![CDATA[
npm 中使用的版本管理模式被称为 <a data-tooltip-position="top" aria-label="https://semver.org/" rel="noopener nofollow" class="external-link is-unresolved" href="https://semver.org/" target="_self">semver</a><br>
- To keep the <a data-href="JavaScript" href="https://rinodg.pages.dev/computer/web-applications/javascript.html#_0" class="internal-link" target="_self" rel="noopener nofollow">JavaScript</a> ecosystem healthy, reliable, and secure, every time you make significant updates to an npm package you own, we recommend publishing a new version of the package with an updated version number in the package.json file that follows the semantic versioning spec. Following the semantic versioning spec helps other developers who depend on your code understand the extent of changes in a given version, and adjust their own code if necessary.<br>
<a data-href="Debugging Node applications" href="https://rinodg.pages.dev/computer/web-applications/debugging-node-applications.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Debugging Node applications</a>
]]></description><link>https://rinodg.pages.dev/computer/web-applications/node.js.html</link><guid isPermaLink="false">Computer/Web Applications/Node.js.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 10 Dec 2022 15:18:50 GMT</pubDate></item><item><title><![CDATA[Debugging Node applications]]></title><description><![CDATA[js 佬的东西真难用Chrome dev tools调试也可以通过Chrome浏览器的开发者控制台，用命令启动你的应用。node --inspect index.js你可以通过点击Chrome开发者控制台中出现的绿色图标--节点标志--来访问调试器。<img alt="fullstack content" src="https://fullstackopen.com/static/98eea9ee4f184a484417314745f7422a/5a190/37.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">调试视图的工作方式与React应用的工作方式相同。Sources标签可用于设置断点，代码的执行将被暂停。<br><img alt="fullstack content" src="https://fullstackopen.com/static/55e5f6c8afb83433a723a0da5c575a32/5a190/38eb.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">所有应用的console.log消息将出现在调试器的Console标签中。你也可以检查变量的值和执行你自己的JavaScript代码。<br><img alt="fullstack content" src="https://fullstackopen.com/static/f4ab60bfb4c362e50561a48eb231a212/5a190/39ea.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>https://rinodg.pages.dev/computer/web-applications/debugging-node-applications.html</link><guid isPermaLink="false">Computer/Web Applications/Debugging Node applications.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 10 Dec 2022 15:18:41 GMT</pubDate><enclosure url="https://fullstackopen.com/static/98eea9ee4f184a484417314745f7422a/5a190/37.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://fullstackopen.com/static/98eea9ee4f184a484417314745f7422a/5a190/37.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[HTTP GET]]></title><description><![CDATA[<img alt="Detail view of a single event" src="https://fullstackopen.com/static/ddcd5afaeabfc1b0e8a4325bfeff90ee/5a190/3e.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> <br>上半部分，General中的内容，显示浏览器使用<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/GET" target="_self">GET</a>方法向地址<a rel="noopener nofollow" class="external-link is-unresolved" href="https://studies.cs.helsinki.fi/exampleapp" target="_self">https://studies.cs.helsinki.fi/exampleapp</a>发送了一个请求(地址是截图时的，现在已经略有改变)，并且请求是成功的，因为服务器的响应<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_self">状态代码</a> 为200。<br>浏览器的请求（request）和服务器的响应（response）有几个<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" target="_self">头信息</a>。<br><img alt="fullstack content" src="https://fullstackopen.com/static/5e6569d4ad80edce4a03a25358b8f195/5a190/4e.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> <br>上面的响应头Response headers告诉我们，例如，响应的字节大小，以及响应的确切时间。一个重要的头信息<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type" target="_self">Content-Type</a>告诉我们，响应是一个<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/UTF-8" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/UTF-8" target="_self">utf-8</a>格式的文本文件，其内容已经用HTML格式化。这样，浏览器就知道这个响应是一个普通的<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/HTML" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/HTML" target="_self">HTML</a>页面，并将其 "像一个网页一样" 渲染到浏览器。Response标签显示了响应数据，是一个普通的HTML页面。body部分决定了渲染到屏幕上的页面的结构。<br><img alt="Screenshot of the response tab" src="https://fullstackopen.com/static/4e49815c455c943b6eb14fe8cc0cefb3/5a190/5e.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> <br>这个页面包含一个<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/div" target="_self">div</a>元素，它又包含一个标题，一个指向页面notes的链接，以及一个<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/img" target="_self">img</a>标签，并显示创建的笔记数量。因为有了img标签，浏览器又做了一次HTTP-request，从服务器上获取图片kuva.png。该请求的细节如下。<br><img alt="Detail view of the second event" src="https://fullstackopen.com/static/f053fa9082a1ad72066fa193346d0378/5a190/6e.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> <br>该请求是向地址<a rel="noopener nofollow" class="external-link is-unresolved" href="https://studies.cs.helsinki.fi/exampleapp/kuva.png" target="_self">https://studies.cs.helsinki.fi/exampleapp/kuva.png</a>发出的，方法类型是HTTP GET。响应头告诉我们，响应大小为89350字节，其<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type" target="_self">内容类型</a>为image/png，所以它是一个png图像。浏览器利用这些信息将图像正确地渲染在屏幕上。<br>在浏览器上打开网页<a rel="noopener nofollow" class="external-link is-unresolved" href="https://studies.cs.helsinki.fi/exampleap" target="_self">https://studies.cs.helsinki.fi/exampleap</a>，所引起的一系列事件构成了以下<a data-tooltip-position="top" aria-label="https://www.geeksforgeeks.org/unified-modeling-language-uml-sequence-diagrams/" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.geeksforgeeks.org/unified-modeling-language-uml-sequence-diagrams/" target="_self">顺序图</a>。<br><img alt="Sequence diagram of the flow covered above" src="https://fullstackopen.com/static/972354fefd202e82e2c4a64d4d7c6125/5a190/7e.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> 首先，浏览器向服务器发送一个HTTP GET请求，以获取该网页的HTML代码。HTML中的img标签提示浏览器获取图片kuva.png。浏览器将HTML页面和图像渲染到屏幕上。尽管很难注意到，但在图像从服务器上获取之前，HTML页面就已经开始渲染了。The HTTP standard talks about two properties related to request types, safety and idempotence.(idempotence) 冪等是数学和计算机科学中某些操作的属性，它们可以多次应用，而不改变初始应用后的结果。幂等性的概念出现在抽象代数和函数式编程的许多地方。维基百科The HTTP GET request should be safe:In particular, the convention has been established that the GET and HEAD methods SHOULD NOT have the significance of taking an action other than retrieval. These methods ought to be considered "safe".
Safety means that the executing request must not cause any side effects in the server. By side-effects we mean that the state of the database must not change as a result of the request, and the response must only return data that already exists on the server.Nothing can ever guarantee that a GET request is actually safe, this is in fact just a recommendation that is defined in the HTTP standard. By adhering to RESTful principles in our API, GET requests are in fact always used in a way that they are safe.The HTTP standard also defines the request type HEAD, that ought to be safe. In practice HEAD should work exactly like GET but it does not return anything but the status code and response headers. The response body will not be returned when you make a HEAD request.All HTTP requests except POST should be idempotent:Methods can also have the property of "idempotence" in that (aside from error or expiration issues) the side-effects of N &gt; 0 identical requests is the same as for a single request. The methods GET, HEAD, PUT and DELETE share this property
This means that if a request does not generate side-effects, then the result should be the same regardless of how many times the request is sent.If we make an HTTP PUT request to the url /api/notes/10 and with the request we send the data { content: "no side effects!", important: true }, the result is the same regardless of how many times the request is sent.Like safety for the GET request, idempotence is also just a recommendation in the HTTP standard and not something that can be guaranteed simply based on the request type. However, when our API adheres to RESTful principles, then GET, HEAD, PUT, and DELETE requests are used in such a way that they are idempotent.POST is the only HTTP request type that is neither safe nor idempotent. If we send 5 different HTTP POST requests to /api/notes with a body of {content: "many same", important: true}, the resulting 5 notes on the server will all have the same content.]]></description><link>https://rinodg.pages.dev/computer/web-applications/http-get.html</link><guid isPermaLink="false">Computer/Web Applications/HTTP GET.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 10 Dec 2022 08:49:28 GMT</pubDate><enclosure url="https://fullstackopen.com/static/ddcd5afaeabfc1b0e8a4325bfeff90ee/5a190/3e.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://fullstackopen.com/static/ddcd5afaeabfc1b0e8a4325bfeff90ee/5a190/3e.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[REST]]></title><description><![CDATA[让我们扩展我们的应用，使其提供与 <a data-tooltip-position="top" aria-label="https://github.com/typicode/json-server#routes" rel="noopener nofollow" class="external-link is-unresolved" href="https://github.com/typicode/json-server#routes" target="_self">json-server</a> 一样的 RESTful HTTP API。<br>Representational State Transfer，又称 REST，于 2000 年在 Roy Fielding 的 <a data-tooltip-position="top" aria-label="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" rel="noopener nofollow" class="external-link is-unresolved" href="https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm" target="_self">论文</a> 中提出。REST 是一种架构风格，旨在建立可扩展的网络应用。<br>我们不打算深入研究 Fielding 对 REST 的定义，也不打算花时间去思考什么是 RESTful 和什么不是。相反，我们将采取一个更 <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Representational_state_transfer#Applied_to_web_services" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Representational_state_transfer#Applied_to_web_services" target="_self">狭窄的观点</a>，只关注 RESTful APIs 在网络应用中的典型理解。事实上，REST 的原始定义甚至不限于网络应用。<br>我们在 <a data-tooltip-position="top" aria-label="https://fullstackopen.com/en/part2/altering_data_in_server#rest" rel="noopener nofollow" class="external-link is-unresolved" href="https://fullstackopen.com/en/part2/altering_data_in_server#rest" target="_self">前一部分</a> 中提到，在 RESTful 思想中，单一的东西，如我们应用中的笔记，被称为 资源 。每个资源都有一个相关的 URL，这是资源的唯一地址。一个惯例是通过结合资源类型的名称和资源的唯一标识符来创建资源的唯一地址。让我们假设我们的服务的根 URL 是 www.example.com/api。<br>如果我们把笔记的资源类型定义为 笔记 ，那么标识符为 10 的笔记资源的地址就有唯一的地址 <a data-tooltip-position="top" aria-label="http://www.example.com/api/notes/10" rel="noopener nofollow" class="external-link is-unresolved" href="http://www.example.com/api/notes/10" target="_self">www.example.com/api/notes/10</a>。<br>所有笔记资源的整个集合的 URL 是 <a data-tooltip-position="top" aria-label="http://www.example.com/api/notes" rel="noopener nofollow" class="external-link is-unresolved" href="http://www.example.com/api/notes" target="_self">www.example.com/api/notes</a>。我们可以对资源执行不同的操作。要执行的操作是由 HTTP verb 定义的。<br>这就是我们如何设法粗略地定义 REST 所指的 <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_constraints" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Representational_state_transfer#Architectural_constraints" target="_self">统一接口</a>，这意味着一种定义接口的一致方式，使系统有可能合作。<br>这种解释 REST 的方式属于 Richardson 成熟度模型中的 <a data-tooltip-position="top" aria-label="https://martinfowler.com/articles/richardsonMaturityModel.html" rel="noopener nofollow" class="external-link is-unresolved" href="https://martinfowler.com/articles/richardsonMaturityModel.html" target="_self">RESTful 成熟度第二层次</a>。根据 Roy Fielding 提供的定义，我们实际上并没有定义一个 <a data-tooltip-position="top" aria-label="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" rel="noopener nofollow" class="external-link is-unresolved" href="http://roy.gbiv.com/untangled/2008/rest-apis-must-be-hypertext-driven" target="_self">REST API</a>。事实上，世界上绝大部分所谓的 "REST "API 都不符合 Fielding 在其论文中列出的原始标准。<br>在某些地方（例如见 <a data-tooltip-position="top" aria-label="http://shop.oreilly.com/product/9780596529260.do" rel="noopener nofollow" class="external-link is-unresolved" href="http://shop.oreilly.com/product/9780596529260.do" target="_self">Richardson, Ruby: RESTful Web Services</a>），你会看到我们的直接 <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Create,_read,_update_and_delete" target="_self">CRUD</a>API 模型被称为 <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Resource-oriented_architecture" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Resource-oriented_architecture" target="_self">面向资源架构</a> 的例子，而不是 REST。我们将避免陷入语义学的争论，而是回到我们的应用上工作。]]></description><link>https://rinodg.pages.dev/computer/web-applications/rest.html</link><guid isPermaLink="false">Computer/Web Applications/REST.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 10 Dec 2022 06:21:22 GMT</pubDate></item><item><title><![CDATA[React Hooks]]></title><description><![CDATA[为了确保我们的应用正确使用基于钩子的状态函数，有一些限制和规则是我们必须遵循的。<a data-href="useState" href="https://rinodg.pages.dev/computer/web-applications/usestate.html#_0" class="internal-link" target="_self" rel="noopener nofollow">useState</a> 函数（以及课程后面介绍的 <a data-href="useEffect" href="https://rinodg.pages.dev/computer/web-applications/useeffect.html#_0" class="internal-link" target="_self" rel="noopener nofollow">useEffect</a> 函数）不能从循环、条件表达式或任何不是定义组件的函数的地方调用。这样做是为了确保钩子总是以相同的顺序被调用，如果不是这样的话，应用将表现得不正常。简而言之，钩子只能从定义了React组件的函数体内部调用。这里的问题是我们的事件处理程序被定义为一个函数调用，这意味着事件处理程序实际上被分配了函数的返回值，在console.log的情况下是未定义。只有箭头函数的引用被设置为事件处理程序。只有当按钮被点击时才会调用该函数。&lt;button onClick={() =&gt; setValue(0)}&gt;button&lt;/button&gt;
事件处理程序现在是函数() =&gt; setValue(0)。直接在按钮的属性中定义事件处理函数，不是个好主意。你经常会看到事件处理程序被定义在一个单独的地方。在我们应用的以下版本中，我们定义了一个函数，然后被分配到组件函数主体中的handleClick变量。const App = () =&gt; { const [value, setValue] = useState(10) const handleClick = () =&gt; console.log('clicked the button') return ( &lt;div&gt; {value} &lt;button onClick={handleClick}&gt;button&lt;/button&gt; &lt;/div&gt; )
}
handleClick变量现在被分配给一个函数的引用。这个引用被作为onClick属性传递给按钮。&lt;button onClick={handleClick}&gt;button&lt;/button&gt;
自然地，我们的事件处理函数可以由多个命令组成。在这种情况下，我们对箭头函数使用较长的大括号语法。const App = () =&gt; { const [value, setValue] = useState(10) const handleClick = () =&gt; { console.log('clicked the button') setValue(0) } return ( &lt;div&gt; {value} &lt;button onClick={handleClick}&gt;button&lt;/button&gt; &lt;/div&gt; )
}
]]></description><link>https://rinodg.pages.dev/computer/web-applications/react-hooks.html</link><guid isPermaLink="false">Computer/Web Applications/React Hooks.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 10 Dec 2022 05:55:21 GMT</pubDate></item><item><title><![CDATA[useEffect]]></title><description><![CDATA[const hook = () =&gt; { console.log('effect') axios .get('http://localhost:3001/notes') .then(response =&gt; { console.log('promise fulfilled') setNotes(response.data) })
} useEffect(hook, [])
现在我们可以更清楚地看到，函数<a data-tooltip-position="top" aria-label="https://reactjs.org/docs/hooks-reference.html#useeffect" rel="noopener nofollow" class="external-link is-unresolved" href="https://reactjs.org/docs/hooks-reference.html#useeffect" target="_self">useEffect</a>实际上需要两个参数。第一个是一个函数，即effect本身。根据文档的内容。
默认情况下，效果会在每次完成渲染后运行，但你可以选择只在某些值发生变化时启动它。
所以默认情况下，效果是总是在组件被渲染后运行。然而，在我们的例子中，我们只想在第一次渲染时执行效果。<br>useEffect的第二个参数用于<a data-tooltip-position="top" aria-label="https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect" rel="noopener nofollow" class="external-link is-unresolved" href="https://reactjs.org/docs/hooks-reference.html#conditionally-firing-an-effect" target="_self">指定效果的运行频率</a>。如果第二个参数是一个空的数组[]，那么效果就只在组件的第一次渲染时运行。]]></description><link>https://rinodg.pages.dev/computer/web-applications/useeffect.html</link><guid isPermaLink="false">Computer/Web Applications/useEffect.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 09 Dec 2022 13:14:47 GMT</pubDate></item><item><title><![CDATA[React.js]]></title><description><![CDATA[<a data-href="Debugging React applications" href="https://rinodg.pages.dev/computer/web-applications/debugging-react-applications.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Debugging React applications</a><br>
<a data-href="React Hooks" href="https://rinodg.pages.dev/computer/web-applications/react-hooks.html#_0" class="internal-link" target="_self" rel="noopener nofollow">React Hooks</a>]]></description><link>https://rinodg.pages.dev/computer/web-applications/react.js.html</link><guid isPermaLink="false">Computer/Web Applications/React.js.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 08 Dec 2022 02:18:10 GMT</pubDate></item><item><title><![CDATA[Debugging React applications]]></title><description><![CDATA[一个典型的开发者的大部分时间都花在调试和阅读现有的代码上。偶尔我们也会写一两行新的代码，但我们的大部分时间都花在试图弄清楚为什么某个东西坏了或某个东西是如何工作的。因此，良好的调试实践和工具是非常重要的。我们很幸运，在调试方面，React是一个对开发者极其友好的库。在我们继续之前，让我们提醒自己网络开发中最重要的规则之一。
始终保持浏览器的开发者控制台是打开的。 特别是控制台标签应该一直打开，除非有特别的原因要查看其他标签。
保持你的代码和网页一起打开，同时打开，一直打开。记录到控制台决不是调试我们的应用的唯一方法。您可以在Chrome开发者控制台的调试器中暂停应用代码的执行，方法是在代码的任何地方写下<a data-tooltip-position="top" aria-label="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger" rel="noopener nofollow" class="external-link is-unresolved" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/debugger" target="_self">debugger</a>命令。一旦执行到debugger命令被执行的地方，执行将暂停。<br><img alt="fullstack content" src="https://fullstackopen.com/static/4a4bced189180676ff4019f459be833e/5a190/7a.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">通过进入Console标签，很容易检查变量的当前状态。<br><img alt="fullstack content" src="https://fullstackopen.com/static/5ba1388f4d17134dcfc62fbeb2251421/5a190/8a.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>https://rinodg.pages.dev/computer/web-applications/debugging-react-applications.html</link><guid isPermaLink="false">Computer/Web Applications/Debugging React applications.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 08 Dec 2022 02:16:55 GMT</pubDate><enclosure url="https://fullstackopen.com/static/4a4bced189180676ff4019f459be833e/5a190/7a.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://fullstackopen.com/static/4a4bced189180676ff4019f459be833e/5a190/7a.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[useState]]></title><description><![CDATA[useState 是 React 函数组件中的一个 Hook，它提供了一种简单的方法来在组件中管理状态。它的原理是通过在组件内部创建一个闭包来存储状态，并通过调用函数来更新状态。首先，在使用 useState 时，需要传入一个初始状态作为参数，例如：const [count, setCount] = useState(0);
在这个例子中，count 表示组件内部的状态，它的初始值为 0。setCount 是一个函数，它用于更新 count 的值。当组件的某个事件触发时，可以通过调用 setCount 函数来更新状态。例如，当用户点击按钮时，可以通过调用 setCount 函数来将 count 的值加 1：&lt;button onClick={() =&gt; setCount(count + 1)}&gt; Click me
&lt;/button&gt;
这样，每当用户点击按钮时，count 的值就会更新，并且组件会根据最新的状态进行重新渲染。总之，useState 原理是通过创建闭包来存储状态，并通过调用函数来更新状态。它能够让开发者在 React 函数组件中轻松地管理状态，提高组件的可重用性和灵活性。]]></description><link>https://rinodg.pages.dev/computer/web-applications/usestate.html</link><guid isPermaLink="false">Computer/Web Applications/useState.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 08 Dec 2022 01:47:31 GMT</pubDate></item><item><title><![CDATA[GraphQL]]></title><description><![CDATA[GraphQL 有一些替代品。其中最常见的替代品包括 REST 和 gRPC。REST（Representational State Transfer）是一种软件架构风格，它提供了一组规范，用于客户端和服务器之间通过 HTTP 进行通信。REST 支持多种语言和平台，并且在设计时具有简洁性和灵活性。gRPC（Google Remote Procedure Call）是一种高性能、开源的远程过程调用系统，它可以在不同语言之间进行通信。gRPC 使用 HTTP/2 协议进行通信，并支持双向流、流控制和请求/响应多路复用。与 GraphQL 相比，REST 和 gRPC 都有一些优点和缺点。对于 REST，它支持更多的语言和平台，并且在设计时具有简洁性和灵活性。但它的实现相对比较复杂，并且在资源定位和访问控制方面缺乏统一的标准。对于 gRPC，它支持多种语言和平台，并且具有高性能和高可用性。但由于它使用了 HTTP/2 协议，可能会造成与旧版本浏览器或代理服务器的不兼容。因此，REST 和 gRPC 都可以作为 GraphQL 的替代品，但具体使用哪种技术取决于具体的需求和应用场景。对于需要多种语言和平台支持的应用，REST 可能是一个更好的选择。它支持更多的语言和平台，并且在设计时具有简洁性和灵活性。但由于它的实现相对比较复杂，需要开发者清楚地理解 REST 的规范和原则，才能够使用它来设计和开发应用。对于需要高性能和高可用性的应用，gRPC 可能是一个更好的选择。它支持多种语言和平台，并且具有高性能和高可用性。但由于它使用了 HTTP/2 协议，可能会造成与旧版本浏览器或代理服务器的不兼容。因此，使用 gRPC 时，需要考虑到这一点，确保它能够与现有的硬件和软件环境协同工作。总之，REST 和 gRPC 都是可以作为 GraphQL 的替代品，它们各有优点和缺点。在选择技术方案时，应该根据具体的需求和应用场景来进行权衡，以便选择最合适的技术方案。]]></description><link>https://rinodg.pages.dev/computer/web-applications/graphql.html</link><guid isPermaLink="false">Computer/Web Applications/GraphQL.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 07 Dec 2022 13:49:25 GMT</pubDate></item><item><title><![CDATA[Single page applications]]></title><description><![CDATA[SPA风格的网站并不像我们的样例应用那样从服务器上单独获取所有的页面，而是只由一个从服务器上获取的HTML页面组成，其内容由在浏览器中执行的JavaScript来操作。]]></description><link>https://rinodg.pages.dev/computer/web-applications/single-page-applications.html</link><guid isPermaLink="false">Computer/Web Applications/Single page applications.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 06 Dec 2022 17:04:09 GMT</pubDate></item><item><title><![CDATA[Cascading Style Sheets]]></title><description><![CDATA[
Driving problem behind CSS
What font type and size does &lt;h1&gt;Introduction&lt;/h1&gt; generate? Answer: Some default from the browser (HTML tells what browser how) Early HTML - Override defaults with attributes &lt;table border="2" bordercolor="black"&gt; Style sheets were added to address this: Specify style to use rather than browser default
Not have to code styling on every element Key concept: Separate style from content
Content (what to display) is in HTML files
Formatting information (how to display it) is in separate style sheets (.css files).
Use an element attribute named class to link (e.g. &lt;span class="test"&gt;)
Result: define style information once, use in many places Consider can you make all the text in the app slightly bigger?
Or purple is our new company color. <img src="https://i.imgur.com/2ElZpzb.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
<br><img src="https://i.imgur.com/0G9PkNa.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
]]></description><link>https://rinodg.pages.dev/computer/web-applications/cascading-style-sheets.html</link><guid isPermaLink="false">Computer/Web Applications/Cascading Style Sheets.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 06 Dec 2022 14:05:11 GMT</pubDate><enclosure url="https://i.imgur.com/2ElZpzb.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/2ElZpzb.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Document object Model]]></title><description><![CDATA[我们可以将 html 页面看作隐式树结构。html head link script body div h1 div ul li li li form input input
文档对象模型Document Object Model，或DOM，是一个应用编程接口(API)，它能够对与网页相对应的元素树进行程序化修改。]]></description><link>https://rinodg.pages.dev/computer/web-applications/document-object-model.html</link><guid isPermaLink="false">Computer/Web Applications/Document object Model.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 06 Dec 2022 14:01:58 GMT</pubDate></item><item><title><![CDATA[Universal Resource Locator]]></title><description><![CDATA[Hypertext
Text with links to other text Click on links takes you somewhere else
Old idea: Ted Nelson coined the term (early '60s), built Xanadu system
Doug Englebart: "Mother of all demos" in 1968
HyperCard for the Macintosh: 1987 Web adapted the idea, link specification: Uniform Resource Locators (URL) - Provided names for web content <a rel="noopener nofollow" class="external-link is-unresolved" href="http://host.company.com:80/a/b/c.html?user=Alice&amp;year=2008#p2" target="_self">http://host.company.com:80/a/b/c.html?user=Alice&amp;year=2008#p2</a>
Scheme (http:): identifies protocol used to fetch the content.
Host name (//host.company.com): name of a machine to connect to.
Server's port number (80): allows multiple servers to run on the same machine.
Hierarchical portion (/a/b/c.html): used by server to find content.
Query parameters (?user=Alice&amp;year=2008): provides additional parameters
Fragment (#p2): Have browser scroll page to fragment (html: p2 is anchor tag) http: is the most common scheme; it means use the HTTP protocol
https: is similar to http: except that it uses SSL encryption
file: means read a file from the local disk
websocket: means create a TCP connection
mailto: means open an email program composing a message
<br>There are many (~350) other schemes: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.iana.org/assignments/uri-schemes/" target="_self">https://www.iana.org/assignments/uri-schemes/</a> Example: mongodb: points to a MongoDB database Passed to the web server for interpretation. Early web servers: Path name for a static HTML file.
Path name of a program that will generate the HTML content (e.g., foo.php). Web server programmed with routing information Map hierarchical position to function to be performed and possibly the function's parameters Application Programming Interface (API) design, Example: /user/create
/user/list
/user/0x23490
/user/0x23433
/user/delete/0x23433 Traditionally has been to provide parameters to operation:<br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="http://www.company.com/showOrder.php?order=4621047" target="_self">http://www.company.com/showOrder.php?order=4621047</a>
For modern apps has implications of when the browser switches pages
● Browser maintains a notion of current location (i.e. URL)
● Links: content in a page which, when clicked on, causes the browser to go to
URL
● Links are implemented with the &lt;a&gt; tag:
&lt;a href="http://www.company.com/news/2009.html"&gt;2009 News&lt;/a&gt;
What if you want to include a punctuation character in a query value? http://www.stats.com/companyInfo?name=C&amp;H Sugar Any character in a URL other than A-Z, a-z, 0-9, or any of -_.~ must berepresented as %xx, where xx is the hexadecimal value of the character: http://www.stats.com/companyInfo?name=C%26H%20Sugar Escaping is a commonly used technique and also a source of errors
]]></description><link>https://rinodg.pages.dev/computer/web-applications/universal-resource-locator.html</link><guid isPermaLink="false">Computer/Web Applications/Universal Resource Locator.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 06 Dec 2022 08:41:49 GMT</pubDate></item><item><title><![CDATA[HyperText Markup Language]]></title><description><![CDATA[Browser environment is different
Traditional app: GUIs based on pixels Since 1970s: software accessed mapped framebuffers (R/G/B)
Toolkits build higher level GUI widgets (buttons, tables, etc.) Web browsers display Documents described in HTML Until HTML5's canvas region, you couldn't write pixels
Make applications out of documents Early web apps: Multiple documents (pages) with 'form' tag for input
Current: Use JavaScript to dynamically generate and update documents Concept: Markup Language - Include directives with content Directives can dictate presentation or describe content
Idea from the 1960s: RUNOFF
Examples: &lt;i&gt;italics word&lt;/i&gt;, &lt;title&gt;Title words&lt;/title&gt;
Example of a declarative language Approach Start with content to be displayed Annotate it with tags Tags can provide: Meaning of text: &lt;hl&gt; means top-level heading
&lt;p&gt; means paragraph
&lt;ul&gt;&lt;li&gt; for unordered (bulleted) list &lt;h2&gt;Introduction&lt;/h2&gt;
&lt;p&gt;
There are several good reasons for taking
&lt;i&gt;CS142: Web Applications&lt;/i&gt;:
&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
You will learn a variety of interesting concepts.
&lt;/li&gt;
&lt;li&gt;
It may inspire you to change the way software is developed.
&lt;/li&gt;
&lt;li&gt;
It will give you the tools to become fabulously wealthy.
&lt;/li&gt;
&lt;/ul&gt;
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd" target="_self">https://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</a>
Forked into HTML and XHTML (XML-based HTML) XHTML is more strict about adhering to proper syntax For the HTML class projects (1, 2, and 3) we will use XHTML
Users came to depend on browser quirks, so browsers couldn't change Document: hierarchical collection of elements, starting with &lt;html&gt;
Element: start tag, contents, end tag
Elements may be nested
Every element must have an explicit start and end Can use &lt;foo /&gt; as shorthand for &lt;foo&gt;&lt;/foo&gt; Start tags can contain attributes:
&lt;img src="face.jpg"&gt;
&lt;input value-"94301" name = 'zip'&gt;
&lt;div class="header"&gt; Need to handle markup characters in content<br>
<img src="https://i.imgur.com/RiekIdT.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> HTML supports the same tags, same features, but allows quirkier syntax: Can skip some end tags, such as &lt;/br&gt;, &lt;/p&gt;
Not all attributes have to have values:&lt;select multiple&gt;
Elements can overlap: &lt;p&gt;&lt;b&gt;first&lt;/p&gt;&lt;p&gt;second&lt;/b&gt; third&lt;/p&gt; Early browsers tried to "do the right thing" even in the face of incorrect HTML: Ignore unknown tags
Carry on even with obvious syntax errors such as missing &lt;body&gt; or &lt;/html&gt;
Infer the position of missing close tags
Guess that some &lt; characters are literal, as in "What if x &lt; 0?"
Not obvious how to interpret some documents (and browsers differed) Additions tags to allow content definition &lt;article&gt;, &lt;section&gt;, &lt;header&gt;, &lt;footer&gt;, &lt;summary&gt;, &lt;aside&gt;, &lt;details&gt;
&lt;mark&gt;, &lt;figcaption&gt;, &lt;figure&gt;
&lt;nav&gt;, &lt;menuitem&gt; Drawing &lt;svg&gt; - Scalable Vector Graphics - Draw shapes &lt;canvas&gt; - Draw from JavaScript - 3D with WebGL Timed media playback: &lt;video&gt; and &lt;audio&gt;
]]></description><link>https://rinodg.pages.dev/computer/web-applications/hypertext-markup-language.html</link><guid isPermaLink="false">Computer/Web Applications/HyperText Markup Language.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 06 Dec 2022 07:28:09 GMT</pubDate><enclosure url="https://i.imgur.com/RiekIdT.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/RiekIdT.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[A star]]></title><description><![CDATA[<img src="https://i.imgur.com/uSpiUb7.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
How do we get our estimate? Estimate is an arbitrary heuristic h(v, goal).
heuristic: “using experience to learn and improve”
Doesn’t have to be perfect! <br>A star vs <a data-href="Dijkstra" href="https://rinodg.pages.dev/computer/data-structure/dijkstra.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Dijkstra</a><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="http://qiao.github.io/PathFinding.js/visual/" target="_self">http://qiao.github.io/PathFinding.js/visual/</a><br>Note, if edge weights are all equal (as here), <a data-href="Dijkstra" href="https://rinodg.pages.dev/computer/data-structure/dijkstra.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Dijkstra</a>’s algorithm is just <a data-href="Breadth First Search" href="https://rinodg.pages.dev/computer/data-structure/breadth-first-search.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Breadth First Search</a>.This is a good tool for understanding distinction between order in which nodes are visited by the algorithm vs. the order in which they appear on the shortest path.
- Unless you’re really lucky, vastly more nodes are visited than exist on the shortest path.]]></description><link>https://rinodg.pages.dev/computer/data-structure/a-star.html</link><guid isPermaLink="false">Computer/Data Structure/A star.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 06 Dec 2022 01:58:14 GMT</pubDate><enclosure url="https://i.imgur.com/uSpiUb7.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/uSpiUb7.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Depth-First Traversal]]></title><description><![CDATA[This idea of exploring a neighbor’s entire subgraph before moving on to the next neighbor is known as Depth First Traversal.<img src="https://i.imgur.com/HN3PWcs.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">What we just did in DepthFirstPaths is called “DFS Preorder.”
DFS Preorder: Action is before DFS calls to neighbors. Our action was setting edgeTo.
Example: edgeTo[1] was set before
DFS calls to neighbors 2 and 4. <br>One valid DFS preorder for this <a data-href="Graph" href="https://rinodg.pages.dev/computer/data-structure/graph.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Graph</a>: 012543678 Equivalent to the order of dfs calls. Could also do actions in DFS Postorder.
DFS Postorder: Action is after DFS calls to neighbors.
Example: dfs(s): mark(s)
For each unmarked neighbor n of s, dfs(n)
print(s) Results for dfs(0) would be: 347685210
Equivalent to the order of dfs returns.
<br>So too are there many <a data-href="Graph" href="https://rinodg.pages.dev/computer/data-structure/graph.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Graph</a> traversals, given some source:
DFS Preorder: 012543678 (dfs calls).
DFS Postorder: 347685210 (dfs returns).
]]></description><link>https://rinodg.pages.dev/computer/data-structure/depth-first-traversal.html</link><guid isPermaLink="false">Computer/Data Structure/Depth-First Traversal.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 06 Dec 2022 01:58:14 GMT</pubDate><enclosure url="https://i.imgur.com/HN3PWcs.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/HN3PWcs.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Graph]]></title><description><![CDATA[
Trees and Hierarchical Relationships Trees are fantastic for representing strict hierarchical relationships. But not every relationship is hierarchical.
Example: Paris Metro map. That is not a <a data-tooltip-position="top" aria-label="Trees &amp; Tree Mutation" data-href="Trees &amp; Tree Mutation" href="https://rinodg.pages.dev/computer/cs61a/trees-&amp;-tree-mutation.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Tree</a>. that contains cycles A graph consists of: A set of nodes
A set of zero or more edges, each of which connects two nodes all trees are graphs
<br><a data-href="Graph Problems" href="https://rinodg.pages.dev/computer/data-structure/graph-problems.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Graph Problems</a>
<br><a data-href="Depth-First Traversal" href="https://rinodg.pages.dev/computer/data-structure/depth-first-traversal.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Depth-First Traversal</a>
BFS order: Act in order of distance from s. <br>BFS stands for “<a data-href="Breadth First Search" href="https://rinodg.pages.dev/computer/data-structure/breadth-first-search.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Breadth First Search</a>”.
Analogous to “level order”. Search is wide, not deep.
0 1 24 53 68 7 <br><a data-href="Breadth First Search" href="https://rinodg.pages.dev/computer/data-structure/breadth-first-search.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Breadth First Search</a>
在设计算法的时候，选择适合的 Graph API 非常重要
DFS is worse for spindly graphs. Imagine a graph with 10000 nodes all spindly. We'll end up making 10000 recursive calls, which is bad for space.
BFS is worse for "bushy" graphs, because our queue gets used a lot.
<br>Find <a data-href="Shortest Paths" href="https://rinodg.pages.dev/computer/data-structure/shortest-paths.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Shortest Paths</a><br><img src="https://i.imgur.com/xUVT7Jf.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><a data-href="Spanning Trees" href="https://rinodg.pages.dev/computer/data-structure/spanning-trees.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Spanning Trees</a><br>
<a data-href="Minimum Spanning Trees" href="https://rinodg.pages.dev/computer/data-structure/minimum-spanning-trees.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Minimum Spanning Trees</a><br><img src="https://i.imgur.com/JLvANCf.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>https://rinodg.pages.dev/computer/data-structure/graph.html</link><guid isPermaLink="false">Computer/Data Structure/Graph.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 06 Dec 2022 01:58:14 GMT</pubDate><enclosure url="https://i.imgur.com/xUVT7Jf.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/xUVT7Jf.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Graph Problems]]></title><description><![CDATA[
<img title="Graph Queries" src="https://i.imgur.com/ANZR2l0.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
<br>Some well known <a data-href="Graph" href="https://rinodg.pages.dev/computer/data-structure/graph.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Graph</a> problems and their common names:
s-t Path. Is there a path between vertices s and t?
Connectivity. Is the graph connected, i.e. is there a path between all vertices?
Biconnectivity. Is there a vertex whose removal disconnects the graph?
Shortest s-t Path. What is the shortest path between vertices s and t?
Cycle Detection. Does the graph contain any cycles?
Euler Tour. Is there a cycle that uses every edge exactly once?
Hamilton Tour. Is there a cycle that uses every vertex exactly once?
Planarity. Can you draw the graph on paper with no crossing edges?
Isomorphism. Are two graphs isomorphic (the same graph in disguise)?
Difficulty can be deceiving.
<br>An efficient Euler tour algorithm O(# edges) was found as early as 1873 [<a data-tooltip-position="top" aria-label="https://ethkim.github.io/TA/251/eulerian.pdf" rel="noopener nofollow" class="external-link is-unresolved" href="https://ethkim.github.io/TA/251/eulerian.pdf" target="_self">Link</a>].
Despite decades of intense study, no efficient algorithm for a Hamilton tour exists. Best algorithms are exponential time.
]]></description><link>https://rinodg.pages.dev/computer/data-structure/graph-problems.html</link><guid isPermaLink="false">Computer/Data Structure/Graph Problems.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 06 Dec 2022 01:58:14 GMT</pubDate><enclosure url="https://i.imgur.com/ANZR2l0.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/ANZR2l0.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Prim's Algorithm]]></title><description><![CDATA[ <img src="https://i.imgur.com/cvVaXSE.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> Start from some arbitrary start node. Repeatedly add shortest edge (mark black) that has one node inside the MST under construction.
Repeat until V-1 edges. <br>
Demo: <a rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.google.com/presentation/d/1NFLbVeCuhhaZAM1z3s9zIYGGnhT4M4PWwAc-TLmCJjc/edit#slide=id.g9a60b2f52_0_0" target="_self">https://docs.google.com/presentation/d/1NFLbVeCuhhaZAM1z3s9zIYGGnhT4M4PWwAc-TLmCJjc/edit#slide=id.g9a60b2f52_0_0</a> Insert all vertices into fringe PQ, storing vertices in order of distance from source.
Repeat: Remove (closest) vertex v from PQ, and relax all edges pointing from v.
将所有顶点插入流苏PQ，按照与源头的距离顺序存储顶点。
重复：从PQ中移除（最近的）顶点v，并放松所有指向v的边。 It is important to note that MST is not unique. Why does Prim’s work? Special case of generic algorithm. Suppose we add edge e = v-&gt;w.
Side 1 of cut is all vertices connected to start, side 2 is all the others.
No crossing edge is black (all connected edges on side 1).
No crossing edge has lower weight (consider in increasing order). <br>
This is one algorithm to find a MST from a <a data-href="Graph" href="https://rinodg.pages.dev/computer/data-structure/graph.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Graph</a>. It is as follows: Start from some arbitrary start node.
Repeatedly add the shortest edge that has one node inside the MST under construction.
Repeat until there are V-1 edges.
<br>Essentially, this algorithm runs via the same mechanism as <a data-href="Dijkstra" href="https://rinodg.pages.dev/computer/data-structure/dijkstra.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Dijkstra</a>'s algorithm, but while <a data-href="Dijkstra" href="https://rinodg.pages.dev/computer/data-structure/dijkstra.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Dijkstra</a>'s considers candidate nodes by their distance from the source node, Prim's looks at each candidate node's distance from the MST under construction.<br>Thus, the runtime of Prim's if done using the same mechanism as <a data-href="Dijkstra" href="https://rinodg.pages.dev/computer/data-structure/dijkstra.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Dijkstra</a>'s, would be the same as <a data-href="Dijkstra" href="https://rinodg.pages.dev/computer/data-structure/dijkstra.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Dijkstra</a>'s, which is.<br>
Remember, this is because we need to add to a <a data-href="Priority Queue" href="https://rinodg.pages.dev/computer/data-structure/priority-queue.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Priority Queue</a> fringe once for every edge we have, and we need to dequeue from it once for every vertex we have.]]></description><link>https://rinodg.pages.dev/computer/data-structure/prim's-algorithm.html</link><guid isPermaLink="false">Computer/Data Structure/Prim's Algorithm.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 06 Dec 2022 01:58:14 GMT</pubDate><enclosure url="https://i.imgur.com/cvVaXSE.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/cvVaXSE.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Shortest Paths]]></title><description><![CDATA[
Single Source, Multiple Targets: Can represent shortest path from start to every vertex as a shortest paths tree with V-1 edges.
Can find the SPT using <a data-href="Dijkstra" href="https://rinodg.pages.dev/computer/data-structure/dijkstra.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Dijkstra</a>’s algorithm. Single Source, Single Target: <br><a data-href="Dijkstra" href="https://rinodg.pages.dev/computer/data-structure/dijkstra.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Dijkstra</a>’s is inefficient (searches useless parts of the <a data-href="Graph" href="https://rinodg.pages.dev/computer/data-structure/graph.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Graph</a>).
Can represent shortest path as path (with up to V-1 vertices, but probably far fewer).
<br><a data-tooltip-position="top" aria-label="A star" data-href="A star" href="https://rinodg.pages.dev/computer/data-structure/a-star.html#_0" class="internal-link" target="_self" rel="noopener nofollow">A*</a> is potentially much faster than <a data-href="Dijkstra" href="https://rinodg.pages.dev/computer/data-structure/dijkstra.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Dijkstra</a>’s. Consistent heuristic guarantees correct solution. ]]></description><link>https://rinodg.pages.dev/computer/data-structure/shortest-paths.html</link><guid isPermaLink="false">Computer/Data Structure/Shortest Paths.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 06 Dec 2022 01:58:14 GMT</pubDate></item><item><title><![CDATA[Minimum Spanning Trees]]></title><description><![CDATA[ A Minimum <a data-href="Spanning Trees" href="https://rinodg.pages.dev/computer/data-structure/spanning-trees.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Spanning Trees</a> is a spanning tree of minimum total weight. Example: Directly connecting buildings by power lines. 定义图的生成树是它的一棵含有其所有顶点的无环连通子图 。 一幅加杈图的最小生成树 （ MST ）是它的一棵权值 （ 树中所有边的权值之和 ） 最小的生成树 <br>
<a data-href="Determain graph has cycle" href="https://rinodg.pages.dev/computer/data-structure/determain-graph-has-cycle.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Determain graph has cycle</a> Application <br><img src="https://i.imgur.com/sSyZ55b.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
For example, I want to wire up a bunch of towns, that they can all have power. In that case, you are trying to minimize the total cost of all. <br>
与 <a data-href="Shortest Paths" href="https://rinodg.pages.dev/computer/data-structure/shortest-paths.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Shortest Paths</a> 的关系 MST 有的时候恰好是某个 Vertex 的 SPT 设计 MST 算法（行不通的 选择最好的 Vertex
运行 Dijkstra <br>
<a data-href="Cut Property" href="https://rinodg.pages.dev/computer/data-structure/cut-property.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Cut Property</a> <br>
<a data-href="Prim's Algorithm" href="https://rinodg.pages.dev/computer/data-structure/prim's-algorithm.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Prim's Algorithm</a> <br>
<a data-href="Kruskal's Algorithm" href="https://rinodg.pages.dev/computer/data-structure/kruskal's-algorithm.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Kruskal's Algorithm</a> <br><img src="https://i.imgur.com/VE1IQ3i.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<a rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Minimum_spanning_tree#Optimal_algorithm" target="_self">https://en.wikipedia.org/wiki/Minimum_spanning_tree#Optimal_algorithm</a>]]></description><link>https://rinodg.pages.dev/computer/data-structure/minimum-spanning-trees.html</link><guid isPermaLink="false">Computer/Data Structure/Minimum Spanning Trees.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 05 Dec 2022 09:12:34 GMT</pubDate><enclosure url="https://i.imgur.com/sSyZ55b.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/sSyZ55b.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Kruskal's Algorithm]]></title><description><![CDATA[ Initially mark all edges gray. Consider edges in increasing order of weight. Add edge to MST (mark black) unless doing so creates a <a data-tooltip-position="top" aria-label="Determain graph has cycle" data-href="Determain graph has cycle" href="https://rinodg.pages.dev/computer/data-structure/determain-graph-has-cycle.html#_0" class="internal-link" target="_self" rel="noopener nofollow">cycle</a>. Repeat until V-1 edges. <br>
Conceptual Kruskal’s Algorithm Demo (<a data-tooltip-position="top" aria-label="https://docs.google.com/presentation/d/1RhRSYs9Jbc335P24p7vR-6PLXZUl-1EmeDtqieL9ad8/edit?usp=sharing" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.google.com/presentation/d/1RhRSYs9Jbc335P24p7vR-6PLXZUl-1EmeDtqieL9ad8/edit?usp=sharing" target="_self">Link</a>) 按权重增加的顺序考虑边缘。添加到 MST 除非创建循环。
<br><a data-href="weighted quick union" href="https://rinodg.pages.dev/.html" class="internal-link" target="_self" rel="noopener nofollow">weighted quick union</a> <br>
Realistic Kruskal’s Algorithm Implementation Demo (<a data-tooltip-position="top" aria-label="https://docs.google.com/presentation/d/1KpNiR7aLIEG9sm7HgX29nvf3yLD8_vdQEPa0ktQfuYc/edit?usp=sharing" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.google.com/presentation/d/1KpNiR7aLIEG9sm7HgX29nvf3yLD8_vdQEPa0ktQfuYc/edit?usp=sharing" target="_self">Link</a>) 1. Sort all the edges from lightest to heaviest.
2. Taking one edge at a time (in sorted order), add it to our MST under construction if doing so does not introduce a cycle.
3. Repeat until there are {% math %}V-1{% endmath %} edges.
<br>vs <a data-href="Prim's Algorithm" href="https://rinodg.pages.dev/computer/data-structure/prim's-algorithm.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Prim's Algorithm</a>
<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://www.youtube.com/watch?v=vmWSnkBVvQ0" target="_self">https://www.youtube.com/watch?v=vmWSnkBVvQ0</a>
如果有非唯一的权重 edges ，它可能生成同样的 Tree
但总权重都是一样的
]]></description><link>https://rinodg.pages.dev/computer/data-structure/kruskal's-algorithm.html</link><guid isPermaLink="false">Computer/Data Structure/Kruskal's Algorithm.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 05 Dec 2022 09:07:16 GMT</pubDate></item><item><title><![CDATA[Generators]]></title><description><![CDATA[We can create our own custom iterators by writing a&nbsp;generator function, which returns a special type of iterator called a&nbsp;generator. Generator functions have&nbsp;yield&nbsp;statements within the body of the function instead of&nbsp;return&nbsp;statements. Calling a generator function will return a generator object and will&nbsp;not&nbsp;execute the body of the function.For example, let's consider the following generator function:def countdown(n): print("Beginning countdown!") while n &gt;= 0: yield n n -= 1 print("Blastoff!")
Calling&nbsp;countdown(k)&nbsp;will return a generator object that counts down from&nbsp;k&nbsp;to 0. Since generators are iterators, we can call&nbsp;iter&nbsp;on the resulting object, which will simply return the same object. Note that the body is not executed at this point; nothing is printed and no numbers are outputted.&gt;&gt;&gt; c = countdown(5)
&gt;&gt;&gt; c
&lt;generator object countdown ...&gt;
&gt;&gt;&gt; c is iter(c)
True
So how is the counting done? Again, since generators are iterators, we call&nbsp;next&nbsp;on them to get the next element! The first time&nbsp;next&nbsp;is called, execution begins at the first line of the function body and continues until the&nbsp;yield&nbsp;statement is reached. The result of evaluating the expression in the&nbsp;yield&nbsp;statement is returned. The following interactive session continues from the one above.&gt;&gt;&gt; next(c)
Beginning countdown!
5
Unlike functions we've seen before in this course, generator functions can remember their state. On any consecutive calls to&nbsp;next, execution picks up from the line after the&nbsp;yield&nbsp;statement that was previously executed. Like the first call to&nbsp;next, execution will continue until the next&nbsp;yield&nbsp;statement is reached. Note that because of this,&nbsp;Beginning countdown!&nbsp;doesn't get printed again.&gt;&gt;&gt; next(c)
4
&gt;&gt;&gt; next(c)
3
The next 3 calls to&nbsp;next&nbsp;will continue to yield consecutive descending integers until 0. On the following call, a&nbsp;StopIteration&nbsp;error will be raised because there are no more values to yield (i.e. the end of the function body was reached before hitting a&nbsp;yield&nbsp;statement).&gt;&gt;&gt; next(c)
2
&gt;&gt;&gt; next(c)
1
&gt;&gt;&gt; next(c)
0
&gt;&gt;&gt; next(c)
Blastoff!
StopIteration
Separate calls to&nbsp;countdown&nbsp;will create distinct generator objects with their own state. Usually, generators shouldn't restart. If you'd like to reset the sequence, create another generator object by calling the generator function again.&gt;&gt;&gt; c1, c2 = countdown(5), countdown(5)
&gt;&gt;&gt; c1 is c2
False
&gt;&gt;&gt; next(c1)
5
&gt;&gt;&gt; next(c2)
5
Here is a summary of the above: A&nbsp;generator function&nbsp;has a&nbsp;yield&nbsp;statement and returns a&nbsp;generator object. Calling the&nbsp;iter&nbsp;function on a generator object returns the same object without modifying its current state. The body of a generator function is not evaluated until&nbsp;next&nbsp;is called on a resulting generator object. Calling the&nbsp;next&nbsp;function on a generator object computes and returns the next object in its sequence. If the sequence is exhausted,&nbsp;StopIteration&nbsp;is raised. A generator "remembers" its state for the next&nbsp;next&nbsp;call. Therefore, the first&nbsp;next&nbsp;call works like this: Enter the function and run until the line with&nbsp;yield.
Return the value in the&nbsp;yield&nbsp;statement, but remember the state of the function for future&nbsp;next&nbsp;calls. And subsequent&nbsp;next&nbsp;calls work like this: Re-enter the function, start at&nbsp;the line after the&nbsp;yield&nbsp;statement that was previously executed, and run until the next&nbsp;yield&nbsp;statement.
Return the value in the&nbsp;yield&nbsp;statement, but remember the state of the function for future&nbsp;next&nbsp;calls. Calling a generator function returns a brand new generator object (like calling&nbsp;iter&nbsp;on an iterable object). A generator should not restart unless it's defined that way. To start over from the first element in a generator, just call the generator function again to create a new generator. Another useful tool for generators is the&nbsp;yield from&nbsp;statement.&nbsp;yield from&nbsp;will yield all values from an iterator or iterable.&gt;&gt;&gt; def gen_list(lst):
... yield from lst
...
&gt;&gt;&gt; g = gen_list([1, 2, 3, 4])
&gt;&gt;&gt; next(g)
1
&gt;&gt;&gt; next(g)
2
&gt;&gt;&gt; next(g)
3
&gt;&gt;&gt; next(g)
4
&gt;&gt;&gt; next(g)
StopIteration
]]></description><link>https://rinodg.pages.dev/computer/cs61a/generators.html</link><guid isPermaLink="false">Computer/CS61A/Generators.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 05 Dec 2022 08:28:32 GMT</pubDate></item><item><title><![CDATA[Cut Property]]></title><description><![CDATA[
<img src="https://i.imgur.com/Bmd3YH3.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
A cut is an assignment of a graph’s nodes to two non-empty sets.
A crossing edge is an edge which connects a node from one set to a node from the other set.
Cut property: Given any cut, minimum weight crossing edge is in the MST. For rest of today, we’ll assume edge weights are unique. ]]></description><link>https://rinodg.pages.dev/computer/data-structure/cut-property.html</link><guid isPermaLink="false">Computer/Data Structure/Cut Property.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 05 Dec 2022 07:29:12 GMT</pubDate><enclosure url="https://i.imgur.com/Bmd3YH3.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/Bmd3YH3.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Spanning Trees]]></title><description><![CDATA[
Given an undirected graph, a spanning tree T is a subgraph of G, where T: These two properties make it a tree. Is connected.
Is acyclic. This makes it spanning. Includes all of the vertices. Example: <img src="https://i.imgur.com/qzXng80.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
Spanning tree is the black edges and vertices. A Minimum Spanning Trees is a spanning tree of minimum total weight. Example: Directly connecting buildings by power lines. A Minimum Spanning Trees is a spanning tree of minimum total weight. Example: Directly connecting buildings by power lines. ]]></description><link>https://rinodg.pages.dev/computer/data-structure/spanning-trees.html</link><guid isPermaLink="false">Computer/Data Structure/Spanning Trees.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 05 Dec 2022 07:28:56 GMT</pubDate><enclosure url="https://i.imgur.com/qzXng80.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/qzXng80.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Red Black Trees]]></title><description><![CDATA[In&nbsp;<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Computer_science" rel="noopener nofollow" class="external-link is-unresolved" title="Computer science" href="https://en.wikipedia.org/wiki/Computer_science" target="_self">computer science</a>, a&nbsp;red–black tree&nbsp;is a kind of&nbsp;<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" rel="noopener nofollow" class="external-link is-unresolved" title="Self-balancing binary search tree" href="https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree" target="_self">self-balancing binary search tree</a>. Each node stores an extra bit representing "color" ("red" or "black"), used to ensure that the tree remains balanced during insertions and deletions.Binary search trees:Can balance using rotation,but we have no algorithm for doing so(yet).
2·3 trees. Balanced by construction, i.e.no rotations required.<br><a rel="noopener nofollow" class="external-link is-unresolved" href="https://youtu.be/4nZFgj7t52E" target="_self">https://youtu.be/4nZFgj7t52E</a>What is the maximum height of the corresponding LLRB?
o TotaI height is H (black) + H + 1 (red)
= 2H + 1Red black tree is actually a 2-3 tree, .． Right red link —&gt; rotate left.
． two consecutive left links -&gt; rotate right.
． Red left and red right -&gt; flip.]]></description><link>https://rinodg.pages.dev/computer/data-structure/red-black-trees.html</link><guid isPermaLink="false">Computer/Data Structure/Red Black Trees.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 02 Dec 2022 07:31:02 GMT</pubDate></item><item><title><![CDATA[Determain graph has cycle]]></title><description><![CDATA[<img src="https://i.imgur.com/u8Mb0as.jpeg" referrerpolicy="no-referrer" target="_self" class="is-unresolved"> Approach 1: Do DFS from 0 (arbitrary vertex). Keep going until you see a marked vertex.
Potential danger: 1 looks back at 0 and sees marked.
Solution: Just don’t count the node you came from. Worst case runtime: O(V + E) -- do study guide problems to reinforce this. With some cleverness, can give a tighter bound of O(V). Approach 2: Use a WeightedQuickUnionUF object. For each edge, check if the two vertices are connected. If not, union them.
If so, there is a cycle. Worst case runtime: O(V + E α(V)) if we have path compression. <br>
Here α(V) is the <a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Ackermann_function" rel="noopener nofollow" class="external-link is-unresolved" href="https://en.wikipedia.org/wiki/Ackermann_function" target="_self">inverse Ackermann function</a> from <a data-tooltip-position="top" aria-label="https://docs.google.com/presentation/d/1CG8k94aQBUHjJPuO5_9pkNml9NYYWY__a9ed_rFH1j0/edit#slide=id.g636c46f3c_01156" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.google.com/presentation/d/1CG8k94aQBUHjJPuO5_9pkNml9NYYWY__a9ed_rFH1j0/edit#slide=id.g636c46f3c_01156" target="_self">Disjoint Sets</a>. ]]></description><link>https://rinodg.pages.dev/computer/data-structure/determain-graph-has-cycle.html</link><guid isPermaLink="false">Computer/Data Structure/Determain graph has cycle.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 02 Dec 2022 07:25:49 GMT</pubDate><enclosure url="https://i.imgur.com/u8Mb0as.jpeg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/u8Mb0as.jpeg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Hashing]]></title><description><![CDATA[将对象 hash 化存到数组，数组保存有对象列表
<img src="https://i.imgur.com/5KIlasB.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br><img src="https://i.imgur.com/It4xNPL.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved">]]></description><link>https://rinodg.pages.dev/computer/hashing.html</link><guid isPermaLink="false">Computer/Hashing.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 02 Dec 2022 04:46:24 GMT</pubDate><enclosure url="https://i.imgur.com/5KIlasB.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/5KIlasB.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Priority Queue]]></title><description><![CDATA[<img src="https://i.imgur.com/LUsWwlE.jpg" referrerpolicy="no-referrer" target="_self" class="is-unresolved"><br>
<a data-href="Heap" href="https://rinodg.pages.dev/computer/data-structure/heap.html#_0" class="internal-link" target="_self" rel="noopener nofollow">Heap</a>]]></description><link>https://rinodg.pages.dev/computer/data-structure/priority-queue.html</link><guid isPermaLink="false">Computer/Data Structure/Priority Queue.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Fri, 02 Dec 2022 04:44:54 GMT</pubDate><enclosure url="https://i.imgur.com/LUsWwlE.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/LUsWwlE.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Breadth First Search]]></title><description><![CDATA[
Initialize a queue with a starting vertex s and mark that vertex. A queue is a list that has two operations: enqueue (a.k.a. addLast) and dequeue (a.k.a. removeFirst).
Let’s call this the queue our fringe. Repeat until queue is empty: Remove vertex v from the front of the queue.
For each unmarked neighbor n of v: Mark n.
Set edgeTo[n] = v (and/or distTo[n] = distTo[v] + 1).
Add n to end of queue. ]]></description><link>https://rinodg.pages.dev/computer/data-structure/breadth-first-search.html</link><guid isPermaLink="false">Computer/Data Structure/Breadth First Search.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sun, 27 Nov 2022 08:38:26 GMT</pubDate></item><item><title><![CDATA[Tree Traversals]]></title><description><![CDATA[Depth First TraversaIsPreorder traversal: "Visit" a node, then traverse its children: DBACFEG
often use to print directory list
<img src="https://i.imgur.com/SMVJ7dq.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">
lnorder traversal: Traverse left child, visit, then traverse right child: ABCDEFGPostorder traversal; Traverseleft, traverse right, then visit: ACBEGFD
Postorder Traversal for gathering file sizes.postOrder(BSTNode x) { if (x == null) return 0; int total = 0; for (BSTNode c : x.children()) total += postOrder(c) total += x.fileSize(); return total;
} <br><img src="https://i.imgur.com/TY4c4Av.png" referrerpolicy="no-referrer" target="_self" class="is-unresolved">Level Traversals]]></description><link>https://rinodg.pages.dev/computer/data-structure/tree-traversals.html</link><guid isPermaLink="false">Computer/Data Structure/Tree Traversals.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Sat, 26 Nov 2022 03:01:15 GMT</pubDate><enclosure url="https://i.imgur.com/SMVJ7dq.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="https://i.imgur.com/SMVJ7dq.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Trees & Tree Mutation]]></title><description><![CDATA[In computer science,&nbsp;trees&nbsp;are recursive data structures that are widely used in various settings and can be implemented in many ways. The diagram below is an example of a tree.Generally in computer science, you may see trees drawn "upside-down" like so. We say the&nbsp;root&nbsp;is the node where the tree begins to branch out at the top, and the&nbsp;leaves&nbsp;are the nodes where the tree ends at the bottom.Some terminology regarding trees:
Parent Node: A node that has at least one branch.
Child Node: A node that has a parent. A child node can only have one parent.
Root: The top node of the tree. In our example, this is the&nbsp;1&nbsp;node.
Label: The value at a node. In our example, every node's label is an integer.
Leaf: A node that has no branches. In our example, the&nbsp;4,&nbsp;5,&nbsp;6,&nbsp;2&nbsp;nodes are leaves.
Branch: A subtree of the root. Trees have branches, which are trees themselves: this is why trees are&nbsp;recursive&nbsp;data structures.
Depth: How far away a node is from the root. We define this as the number of edges between the root to the node. As there are no edges between the root and itself, the root has depth 0. In our example, the&nbsp;3&nbsp;node has depth 1 and the&nbsp;4&nbsp;node has depth 2.
Height: The depth of the lowest (furthest from the root) leaf. In our example, the&nbsp;4,&nbsp;5, and&nbsp;6&nbsp;nodes are all the lowest leaves with depth 2. Thus, the entire tree has height 2.
In computer science, there are many different types of trees, used for different purposes. Some vary in the number of branches each node has; others vary in the structure of the tree.A tree has a root value and a list of branches, where each branch is itself a tree.
The&nbsp;Tree&nbsp;constructor takes in a value&nbsp;label&nbsp;for the root, and an optional list of branches&nbsp;branches. If&nbsp;branches&nbsp;isn't given, the constructor uses the empty list&nbsp;[]&nbsp;as the default.
To get the label of a tree&nbsp;t, we access the instance attribute&nbsp;t.label.
Accessing the instance attribute&nbsp;t.branches&nbsp;will give us a&nbsp;list of branches.
With this in mind, we can create the tree from earlier using our constructor:t = Tree(1, [Tree(3, [Tree(4), Tree(5), Tree(6)]), Tree(2)])
Implementing trees as a class gives us another advantage: we can specify how we want them to be output by the interpreter by implementing the&nbsp;__repr__&nbsp;and&nbsp;__str__&nbsp;methods.Here is the&nbsp;__repr__&nbsp;method:def __repr__(self): if self.branches: branch_str = ', ' + repr(self.branches) else: branch_str = '' return 'Tree({0}{1})'.format(self.label, branch_str)
With this implementation of&nbsp;__repr__, a&nbsp;Tree&nbsp;instance is displayed as the exact constructor call that created it:&gt;&gt;&gt; t = Tree(4, [Tree(3), Tree(5, [Tree(6)]), Tree(7)])
&gt;&gt;&gt; t
Tree(4, [Tree(3), Tree(5, [Tree(6)]), Tree(7)])
&gt;&gt;&gt; t.branches
[Tree(3), Tree(5, [Tree(6)]), Tree(7)]
&gt;&gt;&gt; t.branches[0]
Tree(3)
&gt;&gt;&gt; t.branches[1]
Tree(5, [Tree(6)])
Here is the&nbsp;__str__&nbsp;method. You do not need to understand how this function is implemented.def __str__(self): def print_tree(t, indent=0): tree_str = ' ' * indent + str(t.label) + "\n" for b in t.branches: tree_str += print_tree(b, indent + 1) return tree_str return print_tree(self).rstrip()
With this implementation of&nbsp;__str__, we can pretty-print a&nbsp;Tree&nbsp;to see both its contents and structure:&gt;&gt;&gt; t = Tree(4, [Tree(3), Tree(5, [Tree(6)]), Tree(7)])
&gt;&gt;&gt; print(t)
4 3 5 6 7
&gt;&gt;&gt; print(t.branches[0])
3
&gt;&gt;&gt; print(t.branches[1])
5 6
]]></description><link>https://rinodg.pages.dev/computer/cs61a/trees-&amp;-tree-mutation.html</link><guid isPermaLink="false">Computer/CS61A/Trees &amp; Tree Mutation.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 24 Nov 2022 06:47:50 GMT</pubDate></item><item><title><![CDATA[Heap]]></title><description><![CDATA[数据结构的 Heap 跟硬件的 Heap 不是一个意思The Tree implemented by array, parent =(k-1/2)]]></description><link>https://rinodg.pages.dev/computer/data-structure/heap.html</link><guid isPermaLink="false">Computer/Data Structure/Heap.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 22 Nov 2022 08:38:52 GMT</pubDate></item><item><title><![CDATA[Krita]]></title><description><![CDATA[<a data-href="栅格化" href="https://rinodg.pages.dev/computer/graphics/栅格化.html#_0" class="internal-link" target="_self" rel="noopener nofollow">栅格化</a><br>Krita 是一款栅格图像处理软件，但它也具备一定的矢量图形编辑功能。如果你是数字绘画初学者，那么请先了解一下栅格图像和<a data-href="矢量图像" href="https://rinodg.pages.dev/computer/graphics/矢量图像.html#_0" class="internal-link" target="_self" rel="noopener nofollow">矢量图像</a>的概念。<br><a data-href="栅格图像" href="https://rinodg.pages.dev/computer/graphics/栅格图像.html#_0" class="internal-link" target="_self" rel="noopener nofollow">栅格图像</a>]]></description><link>https://rinodg.pages.dev/computer/krita.html</link><guid isPermaLink="false">Computer/Krita.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 08 Nov 2022 11:30:26 GMT</pubDate></item><item><title><![CDATA[矢量图像]]></title><description><![CDATA[矢量图形是通过数学方式记录形状的，它们并不依赖像素。如果你在 Krita 的<a data-tooltip-position="top" aria-label="https://docs.krita.org/zh_CN/reference_manual/layers_and_masks/vector_layers.html#vector-layers" rel="noopener nofollow" class="external-link is-unresolved" href="https://docs.krita.org/zh_CN/reference_manual/layers_and_masks/vector_layers.html#vector-layers" target="_self">矢量图层</a>上使用矩形工具绘制了一个四边形，该工具实际上只创建了四个节点，每个节点都有一组 X 轴和 Y 轴坐标，四个节点之间以路径相连，路径被按照指定的参数描边后呈现出实际形状。当你移动了这些节点时，计算机会重新算出连线的路径并按照描边参数重新绘制形状。因此，无论你如何对矢量图形进行变形，它们呈现的图像品质会始终如一，不会劣化。在 Krita 里，矢量图层之外的内容都是栅格图像。]]></description><link>https://rinodg.pages.dev/computer/graphics/矢量图像.html</link><guid isPermaLink="false">Computer/Graphics/矢量图像.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 08 Nov 2022 11:30:02 GMT</pubDate></item><item><title><![CDATA[栅格图像]]></title><description><![CDATA[在数字影像技术中，像素 (pixel，图像元素 Picture Element 的缩写) 是组成图像的最基础的元素。把数字图像放大后你会发现它呈网格状，每个网格单独呈现一种颜色，这些网格中的每一格就是一个像素。由像素构成的图像就是栅格图像。在 Krita 里面，当你使用一个大小为 1 像素的黑色笔刷在白色画布上作画时，你实际上是在把笔刷下面的那个像素的颜色从白改成了黑。如果把某个笔画放大观察，你可以看见许多颜色小方块，它们就是像素：]]></description><link>https://rinodg.pages.dev/computer/graphics/栅格图像.html</link><guid isPermaLink="false">Computer/Graphics/栅格图像.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 08 Nov 2022 11:29:10 GMT</pubDate></item><item><title><![CDATA[栅格化]]></title><description><![CDATA[（英式英語：rasterisation、美式英語：rasterization），又稱光柵化，是将<a data-href="矢量图形" href="https://rinodg.pages.dev/computer/graphics/矢量图形.html#_0" class="internal-link" target="_self" rel="noopener nofollow">矢量图形</a> 格式表示的图像转换成<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E9%BB%9E%E9%99%A3%E5%9C%96" rel="noopener nofollow" class="external-link is-unresolved" title="點陣圖" href="https://zh.wikipedia.org/wiki/%E9%BB%9E%E9%99%A3%E5%9C%96" target="_self">點陣圖</a>以用于<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E6%98%BE%E7%A4%BA%E5%99%A8" rel="noopener nofollow" class="external-link is-unresolved" title="显示器" href="https://zh.wikipedia.org/wiki/%E6%98%BE%E7%A4%BA%E5%99%A8" target="_self">显示器</a>或者<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E5%8D%B0%E8%A1%A8%E6%A9%9F" rel="noopener nofollow" class="external-link is-unresolved" title="印表機" href="https://zh.wikipedia.org/wiki/%E5%8D%B0%E8%A1%A8%E6%A9%9F" target="_self">印表機</a>输出的过程。]]></description><link>https://rinodg.pages.dev/computer/graphics/栅格化.html</link><guid isPermaLink="false">Computer/Graphics/栅格化.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 08 Nov 2022 11:28:18 GMT</pubDate></item><item><title><![CDATA[矢量图形]]></title><description><![CDATA[矢量图形是<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6" rel="noopener nofollow" class="external-link is-unresolved" title="计算机图形学" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6" target="_self">计算机图形学</a>中用<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E7%82%B9" rel="noopener nofollow" class="external-link is-unresolved" title="点" href="https://zh.wikipedia.org/wiki/%E7%82%B9" target="_self">点</a>、<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E7%9B%B4%E7%BA%BF" rel="noopener nofollow" class="external-link is-unresolved" title="直线" href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E7%BA%BF" target="_self">直线</a>或者<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%BE%B9%E5%BD%A2" rel="noopener nofollow" class="external-link is-unresolved" title="多边形" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E8%BE%B9%E5%BD%A2" target="_self">多边形</a>等基于数学方程的几何图元表示的<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%83%8F" rel="noopener nofollow" class="external-link is-unresolved" title="图像" href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%83%8F" target="_self">图像</a>。矢量图形与使用<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E5%83%8F%E7%B4%A0" rel="noopener nofollow" class="external-link is-unresolved" title="像素" href="https://zh.wikipedia.org/wiki/%E5%83%8F%E7%B4%A0" target="_self">像素</a>表示图像的<a data-tooltip-position="top" aria-label="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%9B%BE" rel="noopener nofollow" class="external-link is-unresolved" title="位图" href="https://zh.wikipedia.org/wiki/%E4%BD%8D%E5%9B%BE" target="_self">位图</a>不同。]]></description><link>https://rinodg.pages.dev/computer/graphics/矢量图形.html</link><guid isPermaLink="false">Computer/Graphics/矢量图形.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 08 Nov 2022 11:27:42 GMT</pubDate></item><item><title><![CDATA[git-sha1]]></title><description><![CDATA[
git 會計算文件 hash HeIIoWorld.java 66CCdC645C9d156d5C796dbe6ed768430C1562a2 然後用hash前兩位創建文件夾 .git/0bjects/66 Gitstores the contents in a file called CCdC645C9d156d5C796dbe6ed768430C1562a2
之後文件會被壓縮 zlib Hash 不容易被纂改文件，這會引起hash變化
兩個文件相同hash的概率只有 ]]></description><link>https://rinodg.pages.dev/computer/git-sha1.html</link><guid isPermaLink="false">Computer/git-sha1.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Thu, 20 Oct 2022 02:29:29 GMT</pubDate></item><item><title><![CDATA[git]]></title><description><![CDATA[<a data-href="git-sha1" href="https://rinodg.pages.dev/computer/git-sha1.html#_0" class="internal-link" target="_self" rel="noopener nofollow">git-sha1</a>]]></description><link>https://rinodg.pages.dev/computer/git.html</link><guid isPermaLink="false">Computer/git.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 19 Oct 2022 17:01:51 GMT</pubDate></item><item><title><![CDATA[Iterable Uses]]></title><description><![CDATA[We know that lists are one type of built-in iterable objects. You may have also encountered the&nbsp;range(start, end)&nbsp;function, which creates an iterable of ascending integers from start (inclusive) to end (exclusive).&gt;&gt;&gt; for x in range(2, 6):
... print(x)
...
2
3
4
5
Ranges are useful for many things, including performing some operations for a particular number of iterations or iterating through the indices of a list.There are also some built-in functions that take in iterables and return useful results:
map(f, iterable)&nbsp;- Creates an iterator over&nbsp;f(x)&nbsp;for&nbsp;x&nbsp;in&nbsp;iterable. In some cases, computing a list of the values in this iterable will give us the same result as [func(x)&nbsp;for&nbsp;x&nbsp;in&nbsp;iterable]. However, it's important to keep in mind that iterators can potentially have infinite values because they are evaluated lazily, while lists cannot have infinite elements.
filter(f, iterable)&nbsp;- Creates an iterator over&nbsp;x&nbsp;for each&nbsp;x&nbsp;in&nbsp;iterable&nbsp;if&nbsp;f(x)
zip(iterables*)&nbsp;- Creates an iterator over co-indexed tuples with elements from each of the&nbsp;iterables
reversed(iterable)&nbsp;- Creates an iterator over all the elements in the input iterable in reverse order
list(iterable)&nbsp;- Creates a list containing all the elements in the input&nbsp;iterable
tuple(iterable)&nbsp;- Creates a tuple containing all the elements in the input&nbsp;iterable
sorted(iterable)&nbsp;- Creates a sorted list containing all the elements in the input&nbsp;iterable
reduce(f, iterable)&nbsp;- Must be imported with&nbsp;functools. Apply function of two arguments&nbsp;f&nbsp;cumulatively to the items of&nbsp;iterable, from left to right, so as to reduce the sequence to a single value.
]]></description><link>https://rinodg.pages.dev/computer/cs61a/iterable-uses.html</link><guid isPermaLink="false">Computer/CS61A/Iterable Uses.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 01 Aug 2022 11:47:54 GMT</pubDate></item><item><title><![CDATA[Pure functions & Non-pure functions]]></title><description><![CDATA[<a data-tooltip-position="top" aria-label="https://composingprograms.com/pages/12-elements-of-programming.html" rel="noopener nofollow" class="external-link is-unresolved" href="https://composingprograms.com/pages/12-elements-of-programming.html" target="_self">1.2 Elements of Programming</a>
- Pure functions. Functions have some input (their arguments) and return some output (the result of applying them). The built-in function
- Non-pure functions. In addition to returning a value, applying a non-pure function can generate side effects, which make some change to the state of the interpreter or computer. A common side effect is to generate additional output beyond the return value, using the print function.Non-pure functionsNon-pure functions]]></description><link>https://rinodg.pages.dev/computer/cs61a/pure-functions-&amp;-non-pure-functions.html</link><guid isPermaLink="false">Computer/CS61A/Pure functions &amp; Non-pure functions.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Mon, 01 Aug 2022 11:44:29 GMT</pubDate></item><item><title><![CDATA[Shell]]></title><description><![CDATA[Shell 在计算机科学中指“为用户提供用户界面”的软件，通常指的是命令行界面的解析器。一般来说，这个词是指操作系统中提供访问内核所提供之服务的程序。Shell也用于泛指所有为用户提供操作界面的程序，也就是程序和用户交互的层面。因此与之相对的是内核，内核不提供和用户的交互功能。]]></description><link>https://rinodg.pages.dev/computer/shell.html</link><guid isPermaLink="false">Computer/Shell.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Tue, 10 May 2022 07:54:04 GMT</pubDate></item><item><title><![CDATA[字符]]></title><description><![CDATA[\b 回退一个 不会删除
\n \r 源自打字机的键盘]]></description><link>https://rinodg.pages.dev/computer/字符.html</link><guid isPermaLink="false">Computer/字符.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 24 Nov 2021 16:05:35 GMT</pubDate></item><item><title><![CDATA[android]]></title><description><![CDATA[fastboot devices -l fastboot flash recovery &lt;***.img&gt; fastboot reboot recovery
]]></description><link>https://rinodg.pages.dev/linux/android.html</link><guid isPermaLink="false">Linux/android.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 24 Nov 2021 16:05:35 GMT</pubDate></item><item><title><![CDATA[docker]]></title><description><![CDATA[docker system df命令，类似于 Linux 上的df命令，用于查看 Docker 的磁盘使用情况:docker system df
TYPE TOTAL ACTIVE SIZE RECLAIMABLE
Images 147 36 7.204GB 3.887GB (53%)
Containers 37 10 104.8MB 102.6MB (97%)
Local Volumes 3 3 1.421GB 0B (0%)
Build Cache 0B 0B
可知，Docker 镜像占用了7.2GB磁盘，Docker 容器占用了104.8MB磁盘，Docker 数据卷占用了1.4GB磁盘。docker system prune命令可以用于清理磁盘，删除关闭的容器、无用的数据卷和网络，以及 dangling 镜像(即无 tag 的镜像)。docker system prune -a命令清理得更加彻底，可以将没有容器使用 Docker 镜像都删掉。注意，这两个命令会把你暂时关闭的容器，以及暂时没有用到的 Docker 镜像都删掉了…所以使用之前一定要想清楚吶。执行docker system prune -a命令之后，Docker 占用的磁盘空间减少了很多：docker system df
TYPE TOTAL ACTIVE SIZE RECLAIMABLE
Images 10 10 2.271GB 630.7MB (27%)
Containers 10 10 2.211MB 0B (0%)
Local Volumes 3 3 1.421GB 0B (0%)
Build Cache 0B 0B
对于旧版的 Docker(版本 1.13 之前)，是没有 docker system 命令的，因此需要进行手动清理。这里给出几个常用的命
删除所有关闭的容器docker ps -a | grep Exit | cut -d ' ' -f 1 | xargs docker rm 删除所有 dangling 镜像(即无 tag 的镜像)：docker rmi $(docker images | grep "^&lt;none&gt;" | awk "{print $3}") 删除所有 dangling 数据卷(即无用的 volume)：docker volume rm $(docker volume ls -qf dangling=true) Fundebug提供实时、专业的错误监控服务，为您的线上代码保驾护航，欢迎大家免费使用！有一次，当我使用 1 与 2 提到的方法清理磁盘之后，发现并没有什么作用，于是，我进行了一系列分析。在 Ubuntu 上，Docker 的所有相关文件，包括镜像、容器等都保存在/var/lib/docker/目录中：du -hs /var/lib/docker/
97G	/var/lib/docker/
Docker 竟然使用了将近100GB磁盘，这也是够了。使用du命令继续查看，可以定位到真正占用这么多磁盘的目录：92G	/var/lib/docker/containers/a376aa694b22ee497f6fc9f7d15d943de91c853284f8f105ff5ad6c7ddae7a53
由docker ps可知，nginx 容器的 ID 恰好为a376aa694b22，与上面的目录/var/lib/docker/containers/a376aa694b22的前缀一致：docker ps
CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES
a376aa694b22 192.168.59.224:5000/nginx:1.12.1 "nginx -g 'daemon off" 9 weeks ago Up 10 minutes nginx
因此，nginx 容器竟然占用了92GB的磁盘。进一步分析可知，真正占用磁盘空间的是 nginx 的日志文件。那么这就不难理解了。我们Fundebug每天的数据请求为百万级别，那么日志数据自然非常大。使用truncate命令，可以将 nginx 容器的日志文件“清零”：truncate -s 0 /var/lib/docker/containers/a376aa694b22ee497f6fc9f7d15d943de91c853284f8f105ff5ad6c7ddae7a53/*-json.log
当然，这个命令只是临时有作用，日志文件迟早又会涨回来。要从根本上解决问题，需要限制 nginx 容器的日志文件大小。这个可以通过配置日志的max-size来实现，下面是 nginx 容器的 docker-compose 配置文件：nginx:
image: nginx:1.12.1
restart: always
logging:
driver: "json-file"
options:
max-size: "5g"
重启 nginx 容器之后，其日志文件的大小就被限制在5GB，再也不用担心了~还有一次，当我清理了镜像、容器以及数据卷之后，发现磁盘空间并没有减少。根据Docker disk usage提到过的建议，我重启了 Docker，发现磁盘使用率从 83%降到了 19%。根据高手指点，这应该是与内核 3.13 相关的 BUG，导致 Docker 无法清理一些无用目录：it’s quite likely that for some reason when those container shutdown, docker couldn’t remove the directory because the shm device was busy. This tends to happen often on 3.13 kernel. You may want to update it to the 4.4 version supported on trusty 14.04.5 LTS.The reason it disappeared after a restart, is that daemon probably tried and succeeded to clean up left over data from stopped containers.我查看了一下内核版本，发现真的是 3.13:uname -r
3.13.0-86-generic
如果你的内核版本也是 3.13，而且清理磁盘没能成功，不妨重启一下 Docker。当然，这个晚上操作比较靠谱。]]></description><link>https://rinodg.pages.dev/linux/docker.html</link><guid isPermaLink="false">Linux/docker.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 24 Nov 2021 16:05:35 GMT</pubDate></item><item><title><![CDATA[git]]></title><description><![CDATA[git commit --amend -m "messsage"
git commit --amend --author="NewAuthor &lt;NewEmail@address.com&gt;"如果是多个修改，那么就需要使用到 git filter-branch 这个工具来做批量修改
为了方便使用，封装了一个简单的shell脚本，直接修改 [XXX] 中的变量为对应的值即可#!/bin/sh git filter-branch --env-filter ' an="$GIT_AUTHOR_NAME"
am="$GIT_AUTHOR_EMAIL"
cn="$GIT_COMMITTER_NAME"
cm="$GIT_COMMITTER_EMAIL" if [ "$GIT_COMMITTER_EMAIL" = "[Your Old Email]" ]
then cn="[Your New Author Name]" cm="[Your New Email]"
fi
if [ "$GIT_AUTHOR_EMAIL" = "[Your Old Email]" ]
then an="[Your New Author Name]" am="[Your New Email]"
fi export GIT_AUTHOR_NAME="$an"
export GIT_AUTHOR_EMAIL="$am"
export GIT_COMMITTER_NAME="$cn"
export GIT_COMMITTER_EMAIL="$cm"
'
git checkout的--orphanname: Push to master on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: # the checkout action persists the passed credentials by default # subsequent git commands will pick them up automatically - uses: actions/checkout@v2 with: token: ${{secrets.PAT}} - run: | # do something git push
git config --global core.quotepath false设置 git config --global http.https://github.com.proxy socks5://127.0.0.1:1086
设置完成后, ~/.gitconfig 文件中会增加以下条目:[http "https://github.com"] proxy = socks5://127.0.0.1:1086
修改 ~/.ssh/config 文件Host github.com User git ProxyCommand nc -v -x 127.0.0.1:1086 %h %p
]]></description><link>https://rinodg.pages.dev/linux/git.html</link><guid isPermaLink="false">Linux/git.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 24 Nov 2021 16:05:35 GMT</pubDate></item><item><title><![CDATA[shell]]></title><description><![CDATA[使用sh:#!/bin/sh
value=`cat config.txt`
echo "$value"
在bash或zsh中，将整个文件读入变量而无需调用cat:
#!/bin/bash
value=$(&lt;config.txt)
echo "$value"
]]></description><link>https://rinodg.pages.dev/linux/shell.html</link><guid isPermaLink="false">Linux/shell.md</guid><dc:creator><![CDATA[icealtria]]></dc:creator><pubDate>Wed, 24 Nov 2021 16:05:35 GMT</pubDate></item></channel></rss>